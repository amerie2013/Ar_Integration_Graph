<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø®ØªØ¨Ø± Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #geometry-engine-root { height: 100vh; width: 100vw; }
        canvas { touch-action: none; }
        .sidebar-scroll { overflow-y: auto; scrollbar-width: thin; }
        .sidebar-scroll::-webkit-scrollbar { width: 8px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: linear-gradient(to bottom, #6366f1, #8b5cf6); border-radius: 10px; }
        .sidebar-scroll::-webkit-scrollbar-track { background: #f1f5f9; }
        .zoom-controls { position: absolute; bottom: 24px; left: 24px; display: flex; flex-direction: column; gap: 8px; z-index: 30; }
        .zoom-btn { width: 44px; height: 44px; background: white; border: none; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: #475569; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1); transition: all 0.3s; cursor: pointer; }
        .zoom-btn:hover { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; transform: translateY(-2px); }
        .embed-hidden { display: none !important; }
        .embed-controller { position: absolute; bottom: 24px; right: 24px; left: 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; padding: 16px; z-index: 50; display: flex; flex-direction: column; gap: 12px; box-shadow: 0 20px 40px -15px rgba(0,0,0,0.2); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .animate-slide-in { animation: slideIn 0.3s ease-out; }
        .animate-fade-in { animation: fadeIn 0.4s ease-out; }
    </style>
</head>
<body>

<div id="geometry-engine-root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback, useMemo } = React;

// Ø¯Ø§Ù„Ø© Ù„Ø¶ØºØ· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Base64
const compressData = (data) => {
    try {
        const jsonString = JSON.stringify(data);
        // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Base64
        const base64 = btoa(encodeURIComponent(jsonString));
        // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø­Ø¬Ù… Ø¨Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ø£Ø­Ø´ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©
        const compressed = base64
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=+$/, '');
        return compressed;
    } catch (e) {
        console.error('Compression error:', e);
        return '';
    }
};

// Ø¯Ø§Ù„Ø© Ù„ÙÙƒ Ø¶ØºØ· Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
const decompressData = (compressed) => {
    try {
        // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Base64
        let base64 = compressed
            .replace(/-/g, '+')
            .replace(/_/g, '/');
        
        // Ø¥Ø¶Ø§ÙØ© padding Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
        while (base64.length % 4) {
            base64 += '=';
        }
        
        const jsonString = decodeURIComponent(atob(base64));
        return JSON.parse(jsonString);
    } catch (e) {
        console.error('Decompression error:', e);
        return null;
    }
};

const App = () => {
  const params = new URLSearchParams(window.location.search);
  const isEmbedMode = params.get('embed') === 'true';
  const dataParam = params.get('data');
  
  const [showNotification, setShowNotification] = useState(null);

  const showToast = (message, type = 'info') => {
    setShowNotification({ message, type });
    setTimeout(() => setShowNotification(null), 3000);
  };

  // Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ù…Ø¬Ø© Ø¥Ø°Ø§ ÙˆØ¬Ø¯Øª
  const getInitialData = (key, defaultValue) => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : defaultValue;
  };

  const [functions, setFunctions] = useState([]);
  const [sliders, setSliders] = useState([]);
  const [labels, setLabels] = useState([]);
  const [tables, setTables] = useState([]);
  const [images, setImages] = useState([]);
  
  const [showGrid, setShowGrid] = useState(true);
  const [showAxes, setShowAxes] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [gridStepX, setGridStepX] = useState("auto");
  const [gridStepY, setGridStepY] = useState("auto");
  const [isSidebarOpen, setIsSidebarOpen] = useState(!isEmbedMode);
  const [graphTitle, setGraphTitle] = useState("Ù…Ø®ØªØ¨Ø± Ø§Ù„Ø¯ÙˆØ§Ù„ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª");
  const [zoom, setZoom] = useState(40);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [darkMode, setDarkMode] = useState(false);
  const [iframeCode, setIframeCode] = useState('');
  
  const dragStart = useRef({ x: 0, y: 0 });
  const canvasRef = useRef(null);

  // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù†Ø¯ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©
  useEffect(() => {
    if (dataParam) {
      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ù…Ø¬Ø©
      const data = decompressData(dataParam);
      if (data) {
        if (data.f) setFunctions(data.f);
        if (data.s) setSliders(data.s);
        if (data.t) setTables(data.t);
        if (data.l) setLabels(data.l);
        if (data.title) setGraphTitle(data.title);
        if (data.grid !== undefined) setShowGrid(data.grid);
        if (data.axes !== undefined) setShowAxes(data.axes);
        if (data.labels !== undefined) setShowLabels(data.labels);
        if (data.dark !== undefined) setDarkMode(data.dark);
        showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ', 'success');
      }
    } else {
      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© Ù…Ø­Ù„ÙŠØ§Ù‹
      setFunctions(getInitialData('geo_functions', [
        { id: 'f1', expression: "y > x^2", color: '#ef4444', visible: true, thickness: 3, domainMin: '', domainMax: '', rangeMin: '', rangeMax: '', fillOpacity: 0.3 }
      ]));
      setSliders(getInitialData('geo_sliders', [
        { id: 's1', name: 'a', value: 1, min: -10, max: 10, step: 0.1, isAnimating: false, speed: 1, mode: 'forward', direction: 1 }
      ]));
      setLabels(getInitialData('geo_labels', [
        { id: 'l1', text: "Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„", x: "0", y: "0", color: '#475569', visible: true, showPoint: true, rotation: "0", fontSize: "14", backgroundColor: 'transparent' }
      ]));
      setTables(getInitialData('geo_tables', [
        { id: 't1', name: "Ø¬Ø¯ÙˆÙ„ Ø¨ÙŠØ§Ù†Ø§Øª", visible: true, color: '#10b981', pointShape: 'circle', points: [{ x: "1", y: "1" }, { x: "2", y: "3" }], showLines: false, lineType: 'solid' }
      ]));
    }
  }, [dataParam]);

  // Ø­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ localStorage
  useEffect(() => {
    localStorage.setItem('geo_functions', JSON.stringify(functions));
    localStorage.setItem('geo_sliders', JSON.stringify(sliders));
    localStorage.setItem('geo_labels', JSON.stringify(labels));
    localStorage.setItem('geo_tables', JSON.stringify(tables));
  }, [functions, sliders, labels, tables]);

  // ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ iframe
  useEffect(() => {
    const generateIframeCode = () => {
      const dataToSave = {
        f: functions,
        s: sliders,
        t: tables,
        l: labels,
        title: graphTitle,
        grid: showGrid,
        axes: showAxes,
        labels: showLabels,
        dark: darkMode,
        ver: "1.0"
      };
      
      const compressed = compressData(dataToSave);
      if (!compressed) return '<iframe src="..." width="800" height="600"></iframe>';
      
      const baseUrl = window.location.origin + window.location.pathname;
      const embedUrl = `${baseUrl}?embed=true&data=${compressed}`;
      
      return `<iframe src="${embedUrl}" width="800" height="600" style="border: 2px solid #6366f1; border-radius: 12px;" frameborder="0" allowfullscreen></iframe>`;
    };
    
    setIframeCode(generateIframeCode());
  }, [functions, sliders, tables, labels, graphTitle, showGrid, showAxes, showLabels, darkMode]);

  const currentContext = useMemo(() => {
    const ctx = {};
    sliders.forEach(s => { ctx[s.name.toLowerCase()] = s.value; });
    return ctx;
  }, [sliders]);

  const gridOptions = ["auto", 0.1, 0.5, 1, 2, 5, 10, 20, 50, 100, "pi"];
  const parseStep = (val) => val === "pi" ? Math.PI : (val === "auto" ? null : parseFloat(val));
  const config = { 
    minZoom: 2, 
    maxZoom: 1000, 
    gridColor: darkMode ? '#2d3748' : '#f1f5f9',
    axisColor: darkMode ? '#4a5568' : '#334155',
    labelColor: darkMode ? '#a0aec0' : '#94a3b8',
    backgroundColor: darkMode ? '#1a202c' : 'white'
  };

  // Animation for sliders
  useEffect(() => {
    let animationFrame;
    const animate = () => {
      setSliders(prev => prev.map(s => {
        if (!s.isAnimating) return s;
        let delta = (s.step || 0.1) * s.speed * (s.direction || 1);
        let nextValue = s.value + delta;
        let nextDirection = s.direction || 1;
        if (s.mode === 'forward') { if (nextValue > s.max) nextValue = s.min; nextDirection = 1; } 
        else if (s.mode === 'backward') { if (nextValue < s.min) nextValue = s.max; nextDirection = -1; } 
        else if (s.mode === 'pingpong') { if (nextValue > s.max) { nextValue = s.max; nextDirection = -1; } if (nextValue < s.min) { nextValue = s.min; nextDirection = 1; } }
        return { ...s, value: parseFloat(nextValue.toFixed(2)), direction: nextDirection };
      }));
      animationFrame = requestAnimationFrame(animate);
    };
    if (sliders.some(s => s.isAnimating)) animationFrame = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(animationFrame);
  }, [sliders.some(s => s.isAnimating)]);

  const handleZoom = (delta) => {
    setZoom(prev => {
        const factor = delta > 0 ? 1.2 : 0.8;
        const newZoom = prev * factor;
        return Math.min(config.maxZoom, Math.max(config.minZoom, newZoom));
    });
  };

  const compiledFunctions = useMemo(() => {
    return functions.map(f => {
      try {
        let expr = f.expression.toLowerCase().replace(/\s+/g, '');
        let operator = '=';
        if (expr.includes('>=')) operator = '>=';
        else if (expr.includes('<=')) operator = '<=';
        else if (expr.includes('>')) operator = '>';
        else if (expr.includes('<')) operator = '<';
        else if (expr.includes('=')) operator = '=';
        const parts = expr.split(operator);
        const mathExpr = `(${parts[0]}) - (${parts[1]})`;
        return { ...f, node: math.parse(mathExpr), operator, context: currentContext, error: false };
      } catch (e) { return { ...f, node: null, error: true }; }
    });
  }, [functions, currentContext]);

  const toScreen = (x, y, width, height) => ({ 
    px: width / 2 + (x * zoom) + offset.x, 
    py: height / 2 - (y * zoom) + offset.y 
  });

  const toMath = (px, py, width, height) => ({ 
    x: (px - width / 2 - offset.x) / zoom, 
    y: (height / 2 - py + offset.y) / zoom 
  });

  const getBounds = () => {
    if (!canvasRef.current) return { xMin: -10, xMax: 10, yMin: -10, yMax: 10 };
    const width = canvasRef.current.width;
    const height = canvasRef.current.height;
    const tl = toMath(0, 0, width, height);
    const br = toMath(width, height, width, height);
    return { xMin: tl.x, xMax: br.x, yMin: br.y, yMax: tl.y };
  };

  const resolveVal = (val, context) => {
    if (typeof val === 'number') return val;
    if (val === '') return 0;
    try { 
      return math.evaluate(String(val).toLowerCase(), context); 
    } catch(e) { 
      return parseFloat(val) || 0; 
    }
  };

  const drawPoint = (ctx, px, py, shape, size, color) => {
    ctx.fillStyle = color; 
    ctx.beginPath();
    if (shape === 'square') ctx.rect(px - size, py - size, size * 2, size * 2);
    else if (shape === 'triangle') { 
      ctx.moveTo(px, py - size); 
      ctx.lineTo(px - size, py + size); 
      ctx.lineTo(px + size, py + size); 
      ctx.closePath(); 
    }
    else if (shape === 'diamond') { 
      ctx.moveTo(px, py - size); 
      ctx.lineTo(px + size, py); 
      ctx.lineTo(px, py + size); 
      ctx.lineTo(px - size, py); 
      ctx.closePath(); 
    }
    else ctx.arc(px, py, size, 0, Math.PI * 2);
    ctx.fill();
  };

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const width = canvas.width = canvas.offsetWidth;
    const height = canvas.height = canvas.offsetHeight;
    
    // Clear canvas
    ctx.fillStyle = config.backgroundColor;
    ctx.fillRect(0, 0, width, height);

    const centerX = width / 2 + offset.x;
    const centerY = height / 2 + offset.y;
    const b = getBounds();
    const autoStep = (zoom > 150 ? 0.5 : (zoom < 30 ? 5 : 1));
    const sX = parseStep(gridStepX) || autoStep;
    const sY = parseStep(gridStepY) || autoStep;

    // Draw grid
    if (showGrid) {
      ctx.beginPath(); 
      ctx.strokeStyle = config.gridColor;
      ctx.lineWidth = 0.5;
      for (let x = Math.floor(b.xMin / sX) * sX; x <= b.xMax; x += sX) {
        const p = toScreen(x, 0, width, height);
        ctx.moveTo(p.px, 0); 
        ctx.lineTo(p.px, height);
      }
      for (let y = Math.floor(b.yMin / sY) * sY; y <= b.yMax; y += sY) {
        const p = toScreen(0, y, width, height);
        ctx.moveTo(0, p.py); 
        ctx.lineTo(width, p.py);
      }
      ctx.stroke();
    }

    // Draw axes
    if (showAxes) {
      ctx.beginPath(); 
      ctx.strokeStyle = config.axisColor; 
      ctx.lineWidth = 2;
      ctx.moveTo(0, centerY); 
      ctx.lineTo(width, centerY);
      ctx.moveTo(centerX, 0); 
      ctx.lineTo(centerX, height);
      ctx.stroke();
    }

    // Draw labels
    if (showLabels) {
      ctx.fillStyle = config.labelColor; 
      ctx.font = '10px sans-serif';
      for (let i = Math.floor(b.xMin / sX) * sX; i <= b.xMax; i += sX) {
        if (Math.abs(i) < 0.001) continue;
        const p = toScreen(i, 0, width, height);
        ctx.fillText(i.toFixed(1).replace('.0',''), p.px, centerY + 15);
      }
      for (let i = Math.floor(b.yMin / sY) * sY; i <= b.yMax; i += sY) {
        if (Math.abs(i) < 0.001) continue;
        const p = toScreen(0, i, width, height);
        ctx.fillText(i.toFixed(1).replace('.0',''), centerX - 15, p.py + 3);
      }
    }

    // Draw tables
    tables.forEach(table => {
      if (!table.visible) return;
      table.points.forEach(p => {
          if(p.x !== '' && p.y !== '') {
            const vx = resolveVal(p.x, currentContext);
            const vy = resolveVal(p.y, currentContext);
            const sp = toScreen(vx, vy, width, height);
            drawPoint(ctx, sp.px, sp.py, table.pointShape, 5, table.color);
          }
      });
    });

    // Draw labels
    labels.forEach(lbl => {
        if (!lbl.visible) return;
        const rx = resolveVal(lbl.x, currentContext);
        const ry = resolveVal(lbl.y, currentContext);
        const rr = resolveVal(lbl.rotation, currentContext);
        const rs = resolveVal(lbl.fontSize, currentContext);
        const p = toScreen(rx, ry, width, height);
        ctx.save(); 
        ctx.translate(p.px, p.py); 
        ctx.rotate(rr * Math.PI / 180);
        ctx.fillStyle = lbl.color; 
        ctx.font = `bold ${rs}px sans-serif`; 
        ctx.textAlign = 'center';
        ctx.fillText(lbl.text, 0, -12); 
        ctx.restore();
        if (lbl.showPoint) { 
          ctx.beginPath(); 
          ctx.fillStyle = lbl.color; 
          ctx.arc(p.px, p.py, 4, 0, Math.PI * 2); 
          ctx.fill(); 
        }
    });

    // Draw functions
    compiledFunctions.forEach(f => {
      if (!f.visible || f.error || !f.node) return;
      const code = f.node.compile();
      const res = 4; 
      const rows = Math.ceil(height / res); 
      const cols = Math.ceil(width / res);
      const gridData = new Float32Array((rows + 1) * (cols + 1));
      const dMin = f.domainMin !== '' ? parseFloat(f.domainMin) : -Infinity;
      const dMax = f.domainMax !== '' ? parseFloat(f.domainMax) : Infinity;
      const rMin = f.rangeMin !== '' ? parseFloat(f.rangeMin) : -Infinity;
      const rMax = f.rangeMax !== '' ? parseFloat(f.rangeMax) : Infinity;

      for (let j = 0; j <= rows; j++) {
        for (let i = 0; i <= cols; i++) {
          const m = toMath(i * res, j * res, width, height);
          if (m.x < dMin || m.x > dMax || m.y < rMin || m.y > rMax) { 
            gridData[j * (cols + 1) + i] = NaN; 
            continue; 
          }
          try { 
            gridData[j * (cols + 1) + i] = code.evaluate({ x: m.x, y: m.y, ...f.context }); 
          } catch (e) { 
            gridData[j * (cols + 1) + i] = NaN; 
          }
        }
      }
      
      // Draw inequality regions
      if (f.operator !== '=') {
        ctx.fillStyle = f.color + '33';
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            const val = gridData[j * (cols + 1) + i];
            if (isNaN(val)) continue;
            let shouldFill = false;
            if (f.operator === '>' || f.operator === '>=') shouldFill = val > 0;
            if (f.operator === '<' || f.operator === '<=') shouldFill = val < 0;
            if (shouldFill) ctx.fillRect(i * res, j * res, res, res);
          }
        }
      }
      
      // Draw function curve
      ctx.beginPath(); 
      ctx.strokeStyle = f.color; 
      ctx.lineWidth = f.thickness;
      if (f.operator === '>' || f.operator === '<') ctx.setLineDash([10, 5]); 
      else ctx.setLineDash([]);
      
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
          const x0 = i * res, x1 = (i + 1) * res, y0 = j * res, y1 = (j + 1) * res;
          const v0 = gridData[j * (cols + 1) + i];
          const v1 = gridData[j * (cols + 1) + (i + 1)];
          const v2 = gridData[(j + 1) * (cols + 1) + (i + 1)];
          const v3 = gridData[(j + 1) * (cols + 1) + i];
          
          if (isNaN(v0) || isNaN(v1) || isNaN(v2) || isNaN(v3)) continue;
          
          const getEdge = (valA, valB, pA, pB) => { 
            if (valA * valB > 0) return null; 
            const t = Math.abs(valA) / (Math.abs(valA) + Math.abs(valB)); 
            return { x: pA.x + t * (pB.x - pA.x), y: pA.y + t * (pB.y - pA.y) }; 
          };
          
          const edges = [
            getEdge(v0,v1,{x:x0,y:y0},{x:x1,y:y0}),
            getEdge(v1,v2,{x:x1,y:y0},{x:x1,y:y1}),
            getEdge(v2,v3,{x:x1,y:y1},{x:x0,y:y1}),
            getEdge(v3,v0,{x:x0,y:y1},{x:x0,y:y0})
          ].filter(e => e !== null);
          
          if (edges.length >= 2) { 
            ctx.moveTo(edges[0].x, edges[0].y); 
            ctx.lineTo(edges[1].x, edges[1].y); 
          }
        }
      }
      ctx.stroke(); 
      ctx.setLineDash([]);
    });

    // Draw title
    if (graphTitle) {
      ctx.fillStyle = darkMode ? '#e2e8f0' : '#1e293b'; 
      ctx.font = 'bold 22px sans-serif'; 
      ctx.textAlign = 'center';
      ctx.fillText(graphTitle, width / 2, 50);
    }
  }, [compiledFunctions, showGrid, showAxes, showLabels, gridStepX, gridStepY, zoom, offset, graphTitle, labels, tables, sliders, currentContext, darkMode]);

  useEffect(() => { 
    draw(); 
    window.addEventListener('resize', draw); 
    return () => window.removeEventListener('resize', draw); 
  }, [draw]);

  const handleNewProject = () => {
    if(confirm("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ØŸ Ø³ÙŠØªÙ… Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©.")) {
      setFunctions([]); 
      setSliders([]); 
      setLabels([]); 
      setTables([]); 
      setImages([]);
      showToast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯', 'success');
    }
  };

  const handleSaveToFile = () => {
    const data = { 
      version: "1.0",
      functions, sliders, labels, tables, images, graphTitle, zoom, offset,
      settings: { showGrid, showAxes, showLabels, gridStepX, gridStepY, darkMode }
    };
    const blob = new Blob([JSON.stringify(data)], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${graphTitle.replace(/\s+/g, '_')}.geolab`;
    link.click();
    URL.revokeObjectURL(url);
    showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹', 'success');
  };

  const handleOpenFile = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target.result);
        if(data.functions) setFunctions(data.functions);
        if(data.sliders) setSliders(data.sliders);
        if(data.labels) setLabels(data.labels);
        if(data.tables) setTables(data.tables);
        if(data.graphTitle) setGraphTitle(data.graphTitle);
        if(data.zoom) setZoom(data.zoom);
        if(data.offset) setOffset(data.offset);
        if(data.settings) {
            setShowGrid(data.settings.showGrid);
            setShowAxes(data.settings.showAxes);
            setShowLabels(data.settings.showLabels);
            setGridStepX(data.settings.gridStepX);
            setGridStepY(data.settings.gridStepY);
            setDarkMode(data.settings.darkMode);
        }
        showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹', 'success');
      } catch (err) { 
        showToast('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù', 'error');
      }
    };
    reader.readAsText(file);
    e.target.value = '';
  };

  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.src = event.target.result;
        img.onload = () => {
          setImages([...images, { id: 'img' + Date.now(), element: img, x: "0", y: "0", width: "5", rotation: "0", opacity: "1", visible: true }]);
          showToast('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø©', 'success');
        };
      };
      reader.readAsDataURL(file);
    }
  };

  const exportImage = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const link = document.createElement('a');
    link.download = `${graphTitle || 'geometry-lab'}.png`;
    link.href = canvas.toDataURL('image/png');
    link.click();
    showToast('ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„ØµÙˆØ±Ø©', 'success');
  };

  return (
    <div className={`flex h-screen w-screen ${darkMode ? 'bg-gray-900 text-gray-100' : 'bg-white text-gray-900'} overflow-hidden font-sans text-right relative`} dir="rtl">
      
      {/* Notification Toast */}
      {showNotification && (
        <div className={`fixed top-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-lg shadow-lg animate-fade-in ${
          showNotification.type === 'success' ? 'bg-green-500' :
          showNotification.type === 'error' ? 'bg-red-500' :
          'bg-blue-500'
        } text-white font-bold`}>
          {showNotification.message}
        </div>
      )}

      {/* Zoom Controls */}
      <div className={`zoom-controls ${isEmbedMode ? 'embed-hidden' : ''}`}>
          <button onClick={() => handleZoom(1)} className="zoom-btn">+</button>
          <button onClick={() => setZoom(40)} className="zoom-btn">âŒ</button>
          <button onClick={() => handleZoom(-1)} className="zoom-btn">âˆ’</button>
      </div>

      {/* Theme Toggle */}
      <button 
        onClick={() => setDarkMode(!darkMode)}
        className={`absolute top-4 left-4 z-50 p-3 rounded-full ${darkMode ? 'bg-yellow-100 text-yellow-600' : 'bg-gray-800 text-gray-100'} shadow-lg ${isEmbedMode ? 'embed-hidden' : ''}`}
      >
        {darkMode ? 'â˜€ï¸' : 'ğŸŒ™'}
      </button>

      {/* Embed Controller */}
      {isEmbedMode && sliders.length > 0 && (
          <div className="embed-controller animate-slide-in">
              {sliders.map(s => (
                  <div key={s.id} className="flex items-center gap-4">
                      <button 
                        onClick={() => setSliders(prev => prev.map(item => item.id === s.id ? {...item, isAnimating: !item.isAnimating} : item))}
                        className={`w-10 h-10 rounded-full flex items-center justify-center text-white ${s.isAnimating ? 'bg-amber-500' : 'bg-indigo-600'}`}
                      >
                        {s.isAnimating ? 'â¸ï¸' : 'â–¶ï¸'}
                      </button>
                      <div className="flex-1">
                          <div className="flex justify-between text-xs font-bold mb-1">
                              <span>{s.name}</span>
                              <span>{s.value.toFixed(2)}</span>
                          </div>
                          <input 
                            type="range" 
                            min={s.min} 
                            max={s.max} 
                            step={s.step} 
                            value={s.value} 
                            onChange={e => setSliders(prev => prev.map(item => item.id === s.id ? {...item, value: parseFloat(e.target.value)} : item))} 
                            className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" 
                          />
                      </div>
                  </div>
              ))}
          </div>
      )}

      {/* Sidebar Toggle */}
      <button 
        onClick={() => setIsSidebarOpen(!isSidebarOpen)} 
        className={`absolute top-4 right-4 z-50 p-3 ${darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'} border shadow-lg rounded-full transition-all ${isSidebarOpen ? 'mr-80' : 'mr-0'} ${isEmbedMode ? 'embed-hidden' : ''}`}
      >
        <svg xmlns="http://www.w3.org/2000/svg" className={`h-6 w-6 ${isSidebarOpen ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
        </svg>
      </button>

      {/* Main Sidebar */}
      <div className={`fixed inset-y-0 right-0 w-80 ${darkMode ? 'bg-gray-800 border-gray-700' : 'bg-gray-50 border-gray-200'} border-l flex flex-col sidebar-scroll p-6 space-y-6 shadow-2xl z-40 transition-transform ${isSidebarOpen ? 'translate-x-0' : 'translate-x-full'}`}>
        
        <h2 className="font-bold text-xl text-indigo-600 border-b pb-4">Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„</h2>
        
        {/* Quick Actions */}
        <div className="grid grid-cols-2 gap-3">
            <button onClick={handleNewProject} className="p-3 bg-white border rounded-xl font-bold hover:bg-gray-50">ğŸ“„ Ø¬Ø¯ÙŠØ¯</button>
            <label className="p-3 bg-white border rounded-xl font-bold text-center cursor-pointer hover:bg-gray-50">
                ğŸ“‚ ÙØªØ­
                <input type="file" accept=".geolab,.json" className="hidden" onChange={handleOpenFile} />
            </label>
        </div>

        {/* Save Options */}
        <div className="grid grid-cols-2 gap-3">
            <button onClick={handleSaveToFile} className="p-3 bg-indigo-600 text-white rounded-xl font-bold hover:bg-indigo-700">ğŸ’¾ Ø­ÙØ¸</button>
            <button onClick={exportImage} className="p-3 bg-green-600 text-white rounded-xl font-bold hover:bg-green-700">ğŸ“· ØµÙˆØ±Ø©</button>
        </div>

        {/* Add Elements */}
        <div className="grid grid-cols-3 gap-2">
            <button onClick={() => setSliders([...sliders, { id: 's'+Date.now(), name: 'm', value: 1, min: -10, max: 10, step: 0.1, isAnimating: false, speed: 1, mode: 'forward', direction: 1 }])} className="p-2 bg-indigo-100 text-indigo-700 rounded-lg text-xs font-bold hover:bg-indigo-200">+ Ù…Ù†Ø²Ù„Ù‚</button>
            <button onClick={() => setFunctions([...functions, { id: 'f'+Date.now(), expression: "y = x", color: '#3b82f6', visible: true, thickness: 3, domainMin: '', domainMax: '', rangeMin: '', rangeMax: '', fillOpacity: 0.3 }])} className="p-2 bg-blue-100 text-blue-700 rounded-lg text-xs font-bold hover:bg-blue-200">+ Ø¯Ø§Ù„Ø©</button>
            <button onClick={() => setTables([...tables, { id: 't'+Date.now(), name: "Ø¬Ø¯ÙˆÙ„ Ø¬Ø¯ÙŠØ¯", visible: true, color: '#f59e0b', pointShape: 'circle', points: [{ x: "0", y: "0" }], showLines: false, lineType: 'solid' }])} className="p-2 bg-amber-100 text-amber-700 rounded-lg text-xs font-bold hover:bg-amber-200">+ Ø¬Ø¯ÙˆÙ„</button>
            <button onClick={() => setLabels([...labels, { id: 'l'+Date.now(), text: "Ù†Øµ Ø¬Ø¯ÙŠØ¯", x: "2", y: "2", color: '#059669', visible: true, showPoint: true, rotation: "0", fontSize: "14", backgroundColor: 'transparent' }])} className="p-2 bg-green-100 text-green-700 rounded-lg text-xs font-bold hover:bg-green-200">+ Ù†Øµ</button>
            <label className="p-2 bg-red-100 text-red-700 rounded-lg text-xs font-bold text-center cursor-pointer hover:bg-red-200">
                + ØµÙˆØ±Ø©
                <input type="file" accept="image/*" className="hidden" onChange={handleImageUpload} />
            </label>
        </div>

        {/* Sliders */}
        {sliders.map(s => (
            <div key={s.id} className="p-3 bg-white border rounded-xl space-y-2">
                <div className="flex justify-between items-center">
                    <div className="flex items-center gap-2">
                        <button onClick={() => setSliders(prev => prev.map(item => item.id === s.id ? {...item, isAnimating: !item.isAnimating} : item))} className={`w-6 h-6 rounded-full ${s.isAnimating ? 'bg-amber-100 text-amber-600' : 'bg-indigo-100 text-indigo-600'}`}>
                            {s.isAnimating ? 'â¸ï¸' : 'â–¶ï¸'}
                        </button>
                        <input type="text" className="w-8 border-none bg-transparent" value={s.name} onChange={e => setSliders(prev => prev.map(item => item.id === s.id ? {...item, name: e.target.value} : item))} />
                    </div>
                    <span className="font-bold">= {s.value}</span>
                    <button onClick={() => setSliders(sliders.filter(x => x.id !== s.id))} className="text-red-400">ğŸ—‘ï¸</button>
                </div>
                <input type="range" min={s.min} max={s.max} step={s.step} value={s.value} onChange={e => setSliders(prev => prev.map(item => item.id === s.id ? {...item, value: parseFloat(e.target.value)} : item))} className="w-full" />
                <div className="text-xs text-gray-500">
                    <div>Ù…Ù† {s.min} Ø¥Ù„Ù‰ {s.max}</div>
                    <div>Ø³Ø±Ø¹Ø©: {s.speed}x</div>
                </div>
            </div>
        ))}

        {/* Functions */}
        {functions.map(f => (
          <div key={f.id} className="p-3 bg-white border rounded-xl space-y-2">
            <div className="flex gap-2 items-center">
                <input type="color" value={f.color} onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, color: e.target.value} : item))} className="w-6 h-6 border-none cursor-pointer" />
                <input type="text" className="flex-1 p-1 border rounded text-xs font-mono" style={{ direction: 'ltr' }} value={f.expression} onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, expression: e.target.value} : item))} />
                <button onClick={() => setFunctions(functions.filter(x => x.id !== f.id))} className="text-red-400">ğŸ—‘ï¸</button>
            </div>
          </div>
        ))}

        {/* Tables */}
        {tables.map(t => (
          <div key={t.id} className="p-3 bg-white border rounded-xl space-y-2">
            <div className="flex justify-between items-center">
                <div className="flex items-center gap-2">
                    <input type="color" value={t.color} onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, color: e.target.value} : item))} className="w-4 h-4 border-none" />
                    <input type="text" className="w-24 bg-transparent" value={t.name} onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, name: e.target.value} : item))} />
                </div>
                <button onClick={() => setTables(tables.filter(x => x.id !== t.id))} className="text-red-400">ğŸ—‘ï¸</button>
            </div>
            <table className="w-full text-center text-xs">
              <thead><tr><th>X</th><th>Y</th><th></th></tr></thead>
              <tbody>{t.points.map((p, idx) => (
                <tr key={idx}>
                  <td><input type="text" className="w-full p-1 border-none text-center bg-gray-50" value={p.x} onChange={e => setTables(prev => prev.map(tab => tab.id === t.id ? {...tab, points: tab.points.map((pt, i) => i === idx ? {...pt, x: e.target.value} : pt)} : tab))} /></td>
                  <td><input type="text" className="w-full p-1 border-none text-center bg-gray-50" value={p.y} onChange={e => setTables(prev => prev.map(tab => tab.id === t.id ? {...tab, points: tab.points.map((pt, i) => i === idx ? {...pt, y: e.target.value} : pt)} : tab))} /></td>
                  <td><button className="text-red-400" onClick={() => setTables(prev => prev.map(tab => tab.id === t.id ? {...tab, points: tab.points.filter((_, i) => i !== idx)} : tab))}>âœ•</button></td>
                </tr>
              ))}</tbody>
            </table>
            <button className="w-full py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded" onClick={() => setTables(prev => prev.map(tab => tab.id === t.id ? {...tab, points: [...tab.points, {x:"0", y:"0"}]} : tab))}>+ ØµÙ</button>
          </div>
        ))}

        {/* Labels */}
        {labels.map(lbl => (
            <div key={lbl.id} className="p-3 bg-white border rounded-xl space-y-2">
                <div className="flex justify-between items-center">
                    <div className="flex items-center gap-2">
                        <input type="color" value={lbl.color} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, color: e.target.value} : l))} className="w-4 h-4 border-none" />
                        <span className="text-xs font-bold">Ù†Øµ</span>
                    </div>
                    <button onClick={() => setLabels(labels.filter(x => x.id !== lbl.id))} className="text-red-400">ğŸ—‘ï¸</button>
                </div>
                <input type="text" className="w-full p-1 border rounded text-xs" value={lbl.text} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, text: e.target.value} : l))} />
                <div className="grid grid-cols-2 gap-2 text-xs">
                    <div><label>X:</label><input type="text" className="w-full p-1 border rounded text-center" value={lbl.x} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, x: e.target.value} : l))} /></div>
                    <div><label>Y:</label><input type="text" className="w-full p-1 border rounded text-center" value={lbl.y} onChange={e => setLabels(prev => prev.map(l => l.id === lbl.id ? {...l, y: e.target.value} : l))} /></div>
                </div>
            </div>
        ))}

        {/* Footer Section */}
        <div className="mt-auto pt-4 border-t border-gray-200 space-y-4">
            {/* Embed Code */}
            <div className="p-3 bg-indigo-50 border border-indigo-100 rounded-lg space-y-2">
                <label className="text-xs font-bold text-indigo-700">ÙƒÙˆØ¯ Ø§Ù„ØªØ¶Ù…ÙŠÙ†:</label>
                <textarea 
                  readOnly 
                  className="w-full p-2 text-xs font-mono border rounded bg-white" 
                  rows="3" 
                  value={iframeCode} 
                  onClick={(e) => e.target.select()}
                />
                <button 
                  onClick={() => {
                    navigator.clipboard.writeText(iframeCode);
                    showToast('ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„ØªØ¶Ù…ÙŠÙ†', 'success');
                  }}
                  className="w-full py-2 bg-indigo-600 text-white rounded text-xs font-bold hover:bg-indigo-700"
                >
                  Ù†Ø³Ø® Ø§Ù„ÙƒÙˆØ¯
                </button>
            </div>

            {/* Display Settings */}
            <div className="space-y-2 p-3 bg-white border rounded">
                <div className="text-xs font-bold text-gray-600">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶</div>
                <div className="space-y-1 text-xs">
                    <div className="flex justify-between"><span>Ø§Ù„Ù…Ø­Ø§ÙˆØ±</span><input type="checkbox" checked={showAxes} onChange={e => setShowAxes(e.target.checked)} /></div>
                    <div className="flex justify-between"><span>Ø§Ù„Ø´Ø¨ÙƒØ©</span><input type="checkbox" checked={showGrid} onChange={e => setShowGrid(e.target.checked)} /></div>
                    <div className="flex justify-between"><span>Ø§Ù„Ø£Ø±Ù‚Ø§Ù…</span><input type="checkbox" checked={showLabels} onChange={e => setShowLabels(e.target.checked)} /></div>
                </div>
            </div>

            {/* Grid Settings */}
            <div className="grid grid-cols-2 gap-2 bg-white p-3 rounded border">
                <div><label className="text-xs font-bold">Ø´Ø¨ÙƒØ© X:</label><select value={gridStepX} onChange={e => setGridStepX(e.target.value)} className="w-full p-1 border rounded text-xs">{gridOptions.map(opt => <option key={opt} value={opt}>{opt === 'pi' ? 'Ï€' : opt}</option>)}</select></div>
                <div><label className="text-xs font-bold">Ø´Ø¨ÙƒØ© Y:</label><select value={gridStepY} onChange={e => setGridStepY(e.target.value)} className="w-full p-1 border rounded text-xs">{gridOptions.map(opt => <option key={opt} value={opt}>{opt === 'pi' ? 'Ï€' : opt}</option>)}</select></div>
            </div>

            {/* Clear Data */}
            <button onClick={() => {localStorage.clear(); window.location.reload();}} className="w-full py-2 bg-red-50 text-red-600 rounded text-xs font-bold hover:bg-red-100">
                Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
            </button>
        </div>
      </div>

      {/* Main Canvas */}
      <div className="flex-1 relative">
        <canvas 
            ref={canvasRef} 
            onPointerDown={(e) => {
                setIsDragging(true);
                dragStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
            }}
            onPointerMove={(e) => {
                if (isDragging) {
                    setOffset({ 
                        x: e.clientX - dragStart.current.x, 
                        y: e.clientY - dragStart.current.y 
                    });
                }
            }}
            onPointerUp={() => setIsDragging(false)}
            onWheel={(e) => {
                setZoom(z => Math.min(config.maxZoom, Math.max(config.minZoom, z + (e.deltaY > 0 ? -z*0.1 : z*0.1))));
            }}
            className={`w-full h-full ${isDragging ? 'cursor-grabbing' : 'cursor-grab'}`}
        />
        
        {/* Title Editor */}
        {!isEmbedMode && (
            <div className="absolute top-4 left-1/2 transform -translate-x-1/2">
                <input 
                    type="text" 
                    className="text-center p-2 rounded font-bold text-lg bg-white/80 backdrop-blur-sm border"
                    value={graphTitle}
                    onChange={e => setGraphTitle(e.target.value)}
                    style={{ width: '300px' }}
                />
            </div>
        )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('geometry-engine-root'));
root.render(<App />);
</script>
</body>
</html>
