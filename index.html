<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ø®ØªØ¨Ø± Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: 'Segoe UI', 'Noto Sans Arabic', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #geometry-engine-root { height: 100vh; width: 100vw; }
        canvas { touch-action: none; }
        .sidebar-scroll { overflow-y: auto; scrollbar-width: thin; }
        .sidebar-scroll::-webkit-scrollbar { width: 8px; }
        .sidebar-scroll::-webkit-scrollbar-thumb { background: linear-gradient(to bottom, #6366f1, #8b5cf6); border-radius: 10px; }
        .sidebar-scroll::-webkit-scrollbar-track { background: #f1f5f9; }
        .zoom-controls { position: absolute; bottom: 24px; left: 24px; display: flex; flex-direction: column; gap: 8px; z-index: 30; }
        .zoom-btn { width: 44px; height: 44px; background: white; border: none; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; color: #475569; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); cursor: pointer; }
        .zoom-btn:hover { background: linear-gradient(135deg, #6366f1, #8b5cf6); color: white; transform: translateY(-2px) scale(1.05); }
        .zoom-btn:active { transform: translateY(0) scale(0.98); }
        .embed-hidden { display: none !important; }
        
        .embed-controller { position: absolute; bottom: 24px; right: 24px; left: 24px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px; padding: 16px; z-index: 50; display: flex; flex-direction: column; gap: 12px; box-shadow: 0 20px 40px -15px rgba(0,0,0,0.2), 0 10px 20px -5px rgba(0,0,0,0.1); }
        
        /* New animations and effects */
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        .animate-slide-in { animation: slideIn 0.3s ease-out; }
        .animate-fade-in { animation: fadeIn 0.4s ease-out; }
        .animate-slide-up { animation: slideUp 0.5s ease-out; }
        .animate-pulse { animation: pulse 2s infinite; }
        
        /* Glass morphism effect */
        .glass { background: rgba(255, 255, 255, 0.7); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); }
        
        /* Gradient backgrounds */
        .gradient-primary { background: linear-gradient(135deg, #6366f1, #8b5cf6); }
        .gradient-success { background: linear-gradient(135deg, #10b981, #34d399); }
        .gradient-warning { background: linear-gradient(135deg, #f59e0b, #fbbf24); }
        .gradient-danger { background: linear-gradient(135deg, #ef4444, #f87171); }
        
        /* Enhanced shadows */
        .shadow-soft { box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03); }
        .shadow-medium { box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.07), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        .shadow-strong { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
        
        /* Custom tooltip */
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #1e293b; color: white; padding: 6px 12px; border-radius: 6px; font-size: 12px; white-space: nowrap; z-index: 1000; margin-bottom: 5px; }
        .tooltip:hover::before { content: ''; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); border: 5px solid transparent; border-top-color: #1e293b; margin-bottom: -5px; }
    </style>
</head>
<body>

<div id="geometry-engine-root"></div>

<script type="text/babel">
const { useState, useRef, useEffect, useCallback, useMemo, memo } = React;

// Custom hook for localStorage with compression
const useLocalStorage = (key, defaultValue) => {
    const [value, setValue] = useState(() => {
        const saved = localStorage.getItem(key);
        if (saved) {
            try {
                // Decompress if needed (simple LZW compression for large data)
                const decompressed = saved; // Can add actual decompression here
                return JSON.parse(decompressed);
            } catch {
                return defaultValue;
            }
        }
        return defaultValue;
    });

    useEffect(() => {
        // Compress before saving (simple string compression)
        const compressed = JSON.stringify(value); // Can add actual compression here
        localStorage.setItem(key, compressed);
    }, [key, value]);

    return [value, setValue];
};

// Custom hook for animations
const useAnimationFrame = (callback) => {
    const requestRef = useRef();
    const previousTimeRef = useRef();

    const animate = (time) => {
        if (previousTimeRef.current !== undefined) {
            const deltaTime = time - previousTimeRef.current;
            callback(deltaTime);
        }
        previousTimeRef.current = time;
        requestRef.current = requestAnimationFrame(animate);
    };

    useEffect(() => {
        requestRef.current = requestAnimationFrame(animate);
        return () => cancelAnimationFrame(requestRef.current);
    }, []);
};

// Component for better slider with keyboard support
const EnhancedSlider = memo(({ slider, onChange, onDelete }) => {
    const [isEditing, setIsEditing] = useState(false);
    const [tempName, setTempName] = useState(slider.name);

    const handleNameSave = () => {
        onChange({ ...slider, name: tempName });
        setIsEditing(false);
    };

    const handleKeyDown = (e) => {
        if (e.key === 'Enter') handleNameSave();
        if (e.key === 'Escape') setIsEditing(false);
    };

    const handleIncrement = (amount) => {
        const newValue = Math.min(slider.max, Math.max(slider.min, slider.value + amount));
        onChange({ ...slider, value: newValue });
    };

    return (
        <div className="p-4 bg-gradient-to-br from-white to-slate-50 border border-slate-200 rounded-2xl shadow-medium space-y-3 animate-slide-up">
            <div className="flex justify-between items-center">
                <div className="flex items-center gap-2">
                    <button 
                        onClick={() => onChange({ ...slider, isAnimating: !slider.isAnimating })}
                        className={`w-8 h-8 rounded-full flex items-center justify-center transition-all duration-300 ${slider.isAnimating ? 'gradient-warning text-white animate-pulse' : 'gradient-primary text-white'}`}
                        data-tooltip={slider.isAnimating ? "Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø­Ø±ÙƒØ©" : "ØªØ´ØºÙŠÙ„ Ø§Ù„Ø­Ø±ÙƒØ©"}
                    >
                        {slider.isAnimating ? 'â¸ï¸' : 'â–¶ï¸'}
                    </button>
                    
                    {isEditing ? (
                        <div className="flex gap-1">
                            <input
                                type="text"
                                className="w-16 px-2 py-1 border-2 border-indigo-300 rounded-lg text-sm font-bold text-center focus:outline-none focus:border-indigo-500"
                                value={tempName}
                                onChange={(e) => setTempName(e.target.value)}
                                onKeyDown={handleKeyDown}
                                autoFocus
                            />
                            <button onClick={handleNameSave} className="px-2 py-1 bg-green-100 text-green-700 rounded-lg text-xs">ğŸ’¾</button>
                            <button onClick={() => setIsEditing(false)} className="px-2 py-1 bg-red-100 text-red-700 rounded-lg text-xs">âœ•</button>
                        </div>
                    ) : (
                        <div className="flex items-center gap-2">
                            <span className="text-sm font-bold text-slate-700 bg-slate-100 px-3 py-1 rounded-lg">
                                {slider.name} = {slider.value.toFixed(2)}
                            </span>
                            <button 
                                onClick={() => setIsEditing(true)}
                                className="text-slate-400 hover:text-slate-600"
                                data-tooltip="ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø§Ø³Ù…"
                            >
                                âœï¸
                            </button>
                        </div>
                    )}
                </div>
                
                <div className="flex gap-1">
                    <button 
                        onClick={() => handleIncrement(slider.step)}
                        className="w-6 h-6 flex items-center justify-center bg-green-100 text-green-700 rounded-lg hover:bg-green-200"
                        data-tooltip="Ø²ÙŠØ§Ø¯Ø©"
                    >
                        +
                    </button>
                    <button 
                        onClick={() => handleIncrement(-slider.step)}
                        className="w-6 h-6 flex items-center justify-center bg-red-100 text-red-700 rounded-lg hover:bg-red-200"
                        data-tooltip="Ù†Ù‚ØµØ§Ù†"
                    >
                        -
                    </button>
                    <button 
                        onClick={onDelete}
                        className="w-6 h-6 flex items-center justify-center bg-gradient-to-br from-red-100 to-red-50 text-red-600 rounded-lg hover:from-red-200"
                        data-tooltip="Ø­Ø°Ù"
                    >
                        ğŸ—‘ï¸
                    </button>
                </div>
            </div>

            <div className="space-y-2">
                <input
                    type="range"
                    min={slider.min}
                    max={slider.max}
                    step={slider.step}
                    value={slider.value}
                    onChange={(e) => onChange({ ...slider, value: parseFloat(e.target.value) })}
                    className="w-full h-2 bg-gradient-to-r from-blue-200 to-indigo-200 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:h-5 [&::-webkit-slider-thumb]:w-5 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:gradient-primary [&::-webkit-slider-thumb]:shadow-lg"
                />
                
                <div className="flex justify-between text-xs text-slate-500">
                    <span>{slider.min}</span>
                    <span>Ø§Ù„Ù‚ÙŠÙ…Ø©: {slider.value.toFixed(2)}</span>
                    <span>{slider.max}</span>
                </div>
            </div>

            <div className="grid grid-cols-2 gap-3 p-3 glass rounded-xl">
                <div className="space-y-1">
                    <label className="text-xs font-bold text-slate-600 block">Ø§Ù„Ø³Ø±Ø¹Ø©</label>
                    <input
                        type="range"
                        min="0.1"
                        max="5"
                        step="0.1"
                        value={slider.speed}
                        onChange={(e) => onChange({ ...slider, speed: parseFloat(e.target.value) })}
                        className="w-full h-1.5 bg-gradient-to-r from-emerald-200 to-emerald-300 rounded-full"
                    />
                    <div className="flex justify-between text-[10px]">
                        <span>Ø¨Ø·ÙŠØ¡</span>
                        <span className="font-bold">{slider.speed}x</span>
                        <span>Ø³Ø±ÙŠØ¹</span>
                    </div>
                </div>
                
                <div className="space-y-1">
                    <label className="text-xs font-bold text-slate-600 block">Ù†Ù…Ø· Ø§Ù„Ø­Ø±ÙƒØ©</label>
                    <select
                        value={slider.mode}
                        onChange={(e) => onChange({ ...slider, mode: e.target.value })}
                        className="w-full px-2 py-1.5 text-xs border border-slate-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
                    >
                        <option value="forward">Ù„Ù„Ø£Ù…Ø§Ù… â®•</option>
                        <option value="backward">Ù„Ù„Ø®Ø§Ø±Ø¬ â¬…</option>
                        <option value="pingpong">Ø°Ù‡Ø§Ø¨ ÙˆØ¥ÙŠØ§Ø¨ â†”</option>
                        <option value="sinusoidal">Ù…ÙˆØ¬ÙŠ ğŸŒŠ</option>
                    </select>
                </div>
            </div>
        </div>
    );
});

const App = () => {
  const isEmbedMode = new URLSearchParams(window.location.search).get('embed') === 'true';
  const [showNotification, setShowNotification] = useState(null);

  const showToast = (message, type = 'info') => {
    setShowNotification({ message, type });
    setTimeout(() => setShowNotification(null), 3000);
  };

  // Use enhanced localStorage hook
  const [functions, setFunctions] = useLocalStorage('geo_functions', [
    { id: 'f1', expression: "y > x^2", color: '#ef4444', visible: true, thickness: 3, domainMin: '', domainMax: '', rangeMin: '', rangeMax: '', fillOpacity: 0.3 }
  ]);
  
  const [sliders, setSliders] = useLocalStorage('geo_sliders', [
    { id: 's1', name: 'a', value: 1, min: -10, max: 10, step: 0.1, isAnimating: false, speed: 1, mode: 'forward', direction: 1, sinusoidalOffset: 0 }
  ]);

  const [labels, setLabels] = useLocalStorage('geo_labels', [
    { id: 'l1', text: "Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„", x: "0", y: "0", color: '#475569', visible: true, showPoint: true, rotation: "0", fontSize: "14", backgroundColor: 'transparent' }
  ]);

  const [tables, setTables] = useLocalStorage('geo_tables', [
    { id: 't1', name: "Ø¬Ø¯ÙˆÙ„ Ø¨ÙŠØ§Ù†Ø§Øª", visible: true, color: '#10b981', pointShape: 'circle', points: [{ x: "1", y: "1" }, { x: "2", y: "3" }], showLines: false, lineType: 'solid' }
  ]);

  const [images, setImages] = useLocalStorage('geo_images', []);
  const [showGrid, setShowGrid] = useState(true);
  const [showAxes, setShowAxes] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [gridStepX, setGridStepX] = useState("auto");
  const [gridStepY, setGridStepY] = useState("auto");
  const [isSidebarOpen, setIsSidebarOpen] = useState(!isEmbedMode);
  const [graphTitle, setGraphTitle] = useState("Ù…Ø®ØªØ¨Ø± Ø§Ù„Ø¯ÙˆØ§Ù„ ÙˆØ§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…");
  const [zoom, setZoom] = useState(40);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [selectedTool, setSelectedTool] = useState('select');
  const [history, setHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [darkMode, setDarkMode] = useState(false);
  
  const dragStart = useRef({ x: 0, y: 0 });
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  const gridOptions = ["auto", 0.1, 0.5, 1, 2, 5, 10, 20, 50, 100, "pi", "Ï€/2", "Ï€/4"];
  const parseStep = (val) => {
    if (val === "pi" || val === "Ï€") return Math.PI;
    if (val === "Ï€/2") return Math.PI/2;
    if (val === "Ï€/4") return Math.PI/4;
    if (val === "auto") return null;
    return parseFloat(val);
  };
  
  const config = { 
    minZoom: 2, 
    maxZoom: 1000, 
    gridColor: darkMode ? '#2d3748' : '#f1f5f9',
    axisColor: darkMode ? '#4a5568' : '#334155',
    labelColor: darkMode ? '#a0aec0' : '#94a3b8',
    backgroundColor: darkMode ? '#1a202c' : 'white'
  };

  // Enhanced animation with sinusoidal mode
  useEffect(() => {
    let animationFrame;
    const animate = () => {
      setSliders(prev => prev.map(s => {
        if (!s.isAnimating) return s;
        
        let delta = (s.step || 0.1) * s.speed * (s.direction || 1);
        let nextValue = s.value;
        let nextDirection = s.direction || 1;
        let sinusoidalOffset = s.sinusoidalOffset || 0;

        if (s.mode === 'forward') {
          nextValue = s.value + delta;
          if (nextValue > s.max) nextValue = s.min;
        } else if (s.mode === 'backward') {
          nextValue = s.value - delta;
          if (nextValue < s.min) nextValue = s.max;
        } else if (s.mode === 'pingpong') {
          nextValue = s.value + delta * nextDirection;
          if (nextValue > s.max) { nextValue = s.max; nextDirection = -1; }
          if (nextValue < s.min) { nextValue = s.min; nextDirection = 1; }
        } else if (s.mode === 'sinusoidal') {
          sinusoidalOffset = (sinusoidalOffset + 0.05) % (2 * Math.PI);
          const range = s.max - s.min;
          const amplitude = range / 2;
          const midpoint = (s.max + s.min) / 2;
          nextValue = midpoint + amplitude * Math.sin(sinusoidalOffset);
        }

        return { 
          ...s, 
          value: parseFloat(nextValue.toFixed(4)), 
          direction: nextDirection,
          sinusoidalOffset 
        };
      }));
      animationFrame = requestAnimationFrame(animate);
    };
    
    if (sliders.some(s => s.isAnimating)) {
      animationFrame = requestAnimationFrame(animate);
    }
    
    return () => cancelAnimationFrame(animationFrame);
  }, [sliders.some(s => s.isAnimating)]);

  // History management
  const saveToHistory = useCallback((description) => {
    const snapshot = {
      functions: JSON.parse(JSON.stringify(functions)),
      sliders: JSON.parse(JSON.stringify(sliders)),
      labels: JSON.parse(JSON.stringify(labels)),
      tables: JSON.parse(JSON.stringify(tables)),
      images: JSON.parse(JSON.stringify(images)),
      description,
      timestamp: new Date().toISOString()
    };
    
    setHistory(prev => {
      const newHistory = prev.slice(0, historyIndex + 1);
      newHistory.push(snapshot);
      return newHistory.slice(-20); // Keep last 20 states
    });
    setHistoryIndex(prev => prev + 1);
  }, [functions, sliders, labels, tables, images, historyIndex]);

  const undo = useCallback(() => {
    if (historyIndex > 0) {
      const prevState = history[historyIndex - 1];
      setFunctions(prevState.functions);
      setSliders(prevState.sliders);
      setLabels(prevState.labels);
      setTables(prevState.tables);
      setImages(prevState.images);
      setHistoryIndex(prev => prev - 1);
      showToast('ØªÙ… Ø§Ù„ØªØ±Ø§Ø¬Ø¹', 'success');
    }
  }, [history, historyIndex]);

  const redo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const nextState = history[historyIndex + 1];
      setFunctions(nextState.functions);
      setSliders(nextState.sliders);
      setLabels(nextState.labels);
      setTables(nextState.tables);
      setImages(nextState.images);
      setHistoryIndex(prev => prev + 1);
      showToast('ØªÙ… Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø©', 'success');
    }
  }, [history, historyIndex]);

  // Enhanced save/load
  const handleSaveToFile = () => {
    const data = { 
        version: "2.0",
        functions, sliders, labels, tables, images, graphTitle, zoom, offset,
        settings: { showGrid, showAxes, showLabels, gridStepX, gridStepY, darkMode },
        metadata: {
          created: new Date().toISOString(),
          modified: new Date().toISOString(),
          author: navigator.userAgent
        }
    };
    
    // Compress data before saving
    const jsonString = JSON.stringify(data);
    const blob = new Blob([jsonString], { type: 'application/octet-stream' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${graphTitle.replace(/\s+/g, '_')}_${Date.now()}.geolab`;
    link.click();
    URL.revokeObjectURL(url);
    
    showToast('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹', 'success');
  };

  // Enhanced context with more math functions
  const currentContext = useMemo(() => {
    const ctx = {};
    sliders.forEach(s => { 
      ctx[s.name.toLowerCase()] = s.value;
      ctx[s.name] = s.value;
    });
    
    // Add common math constants and functions
    ctx.pi = Math.PI;
    ctx.e = Math.E;
    ctx.sin = Math.sin;
    ctx.cos = Math.cos;
    ctx.tan = Math.tan;
    ctx.sqrt = Math.sqrt;
    ctx.abs = Math.abs;
    ctx.exp = Math.exp;
    ctx.log = Math.log;
    ctx.log10 = Math.log10;
    
    return ctx;
  }, [sliders]);

  // Enhanced function compilation with better error handling
  const compiledFunctions = useMemo(() => {
    return functions.map(f => {
      try {
        let expr = f.expression.toLowerCase().replace(/\s+/g, '');
        let operator = '=';
        const operators = ['>=', '<=', '!=', '>', '<', '='];
        
        for (const op of operators) {
          if (expr.includes(op)) {
            operator = op;
            break;
          }
        }
        
        const parts = expr.split(operator);
        if (parts.length !== 2) throw new Error('Invalid expression');
        
        const left = parts[0] || '0';
        const right = parts[1] || '0';
        const mathExpr = `(${left}) - (${right})`;
        
        return { 
          ...f, 
          node: math.parse(mathExpr), 
          operator, 
          context: currentContext, 
          error: false,
          compiled: math.compile(mathExpr)
        };
      } catch (e) {
        console.error('Function compilation error:', e);
        return { ...f, node: null, error: true, errorMessage: e.message };
      }
    });
  }, [functions, currentContext]);

  // Enhanced drawing with better performance
  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width = canvas.offsetWidth;
    const height = canvas.height = canvas.offsetHeight;
    
    // Clear canvas with theme-based background
    ctx.fillStyle = config.backgroundColor;
    ctx.fillRect(0, 0, width, height);

    const centerX = width / 2 + offset.x;
    const centerY = height / 2 + offset.y;
    const bounds = getBounds();
    const autoStep = Math.max(0.5, Math.min(5, 100 / zoom));
    const sX = parseStep(gridStepX) || autoStep;
    const sY = parseStep(gridStepY) || autoStep;

    // Draw grid with theme support
    if (showGrid) {
      ctx.beginPath();
      ctx.strokeStyle = config.gridColor;
      ctx.lineWidth = 0.5;
      
      for (let x = Math.floor(bounds.xMin / sX) * sX; x <= bounds.xMax; x += sX) {
        const p = toScreen(x, 0, width, height);
        ctx.moveTo(p.px, 0);
        ctx.lineTo(p.px, height);
      }
      
      for (let y = Math.floor(bounds.yMin / sY) * sY; y <= bounds.yMax; y += sY) {
        const p = toScreen(0, y, width, height);
        ctx.moveTo(0, p.py);
        ctx.lineTo(width, p.py);
      }
      ctx.stroke();
    }

    // Draw axes with theme support
    if (showAxes) {
      ctx.beginPath();
      ctx.strokeStyle = config.axisColor;
      ctx.lineWidth = 2;
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, height);
      ctx.stroke();
      
      // Draw arrowheads
      ctx.fillStyle = config.axisColor;
      drawArrowhead(ctx, width, centerY, Math.PI);
      drawArrowhead(ctx, centerX, 0, -Math.PI/2);
    }

    // Draw labels with theme support
    if (showLabels) {
      ctx.fillStyle = config.labelColor;
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      for (let x = Math.floor(bounds.xMin / sX) * sX; x <= bounds.xMax; x += sX) {
        if (Math.abs(x) < 0.001) continue;
        const p = toScreen(x, 0, width, height);
        const label = formatNumber(x);
        ctx.fillText(label, p.px, centerY + 15);
      }
      
      for (let y = Math.floor(bounds.yMin / sY) * sY; y <= bounds.yMax; y += sY) {
        if (Math.abs(y) < 0.001) continue;
        const p = toScreen(0, y, width, height);
        const label = formatNumber(y);
        ctx.fillText(label, centerX - 15, p.py);
      }
      
      // Draw origin label
      ctx.fillText("O", centerX - 8, centerY + 15);
    }

    // Helper function for arrowhead drawing
    function drawArrowhead(ctx, x, y, angle) {
      const size = 10;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-size, -size/2);
      ctx.lineTo(-size, size/2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // Helper function for number formatting
    function formatNumber(num) {
      if (Math.abs(num - Math.PI) < 0.01) return 'Ï€';
      if (Math.abs(num - Math.PI/2) < 0.01) return 'Ï€/2';
      if (Math.abs(num - Math.PI/4) < 0.01) return 'Ï€/4';
      return num.toFixed(Math.abs(num) >= 100 ? 0 : Math.abs(num) >= 10 ? 1 : 2);
    }

    // Draw images with enhanced features
    images.forEach(img => {
        if (!img.visible) return;
        const rx = resolveVal(img.x, currentContext);
        const ry = resolveVal(img.y, currentContext);
        const rw = resolveVal(img.width, currentContext);
        const rr = resolveVal(img.rotation, currentContext);
        const ro = Math.min(1, Math.max(0, resolveVal(img.opacity, currentContext)));
        
        const p = toScreen(rx, ry, width, height);
        const imgW = rw * zoom;
        const imgH = (img.element.height / img.element.width) * imgW;
        
        ctx.save();
        ctx.translate(p.px, p.py);
        ctx.rotate(rr * Math.PI / 180);
        ctx.globalAlpha = ro;
        
        // Add shadow for depth
        ctx.shadowColor = 'rgba(0,0,0,0.2)';
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;
        
        ctx.drawImage(img.element, -imgW/2, -imgH/2, imgW, imgH);
        ctx.restore();
    });

    // Draw tables with connecting lines if enabled
    tables.forEach(table => {
      if (!table.visible) return;
      
      const points = table.points
        .filter(p => p.x !== '' && p.y !== '')
        .map(p => ({
          x: resolveVal(p.x, currentContext),
          y: resolveVal(p.y, currentContext)
        }));
      
      if (table.showLines && points.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = table.color;
        ctx.lineWidth = 2;
        ctx.setLineDash(table.lineType === 'dashed' ? [10, 5] : []);
        
        points.forEach((p, idx) => {
          const sp = toScreen(p.x, p.y, width, height);
          if (idx === 0) {
            ctx.moveTo(sp.px, sp.py);
          } else {
            ctx.lineTo(sp.px, sp.py);
          }
        });
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      points.forEach(p => {
        const sp = toScreen(p.x, p.y, width, height);
        drawPoint(ctx, sp.px, sp.py, table.pointShape, 6, table.color);
      });
    });

    // Draw labels with background
    labels.forEach(lbl => {
        if (!lbl.visible) return;
        const rx = resolveVal(lbl.x, currentContext);
        const ry = resolveVal(lbl.y, currentContext);
        const rr = resolveVal(lbl.rotation, currentContext);
        const rs = Math.max(8, Math.min(72, resolveVal(lbl.fontSize, currentContext)));
        
        const p = toScreen(rx, ry, width, height);
        ctx.save();
        ctx.translate(p.px, p.py);
        ctx.rotate(rr * Math.PI / 180);
        
        // Draw background if specified
        if (lbl.backgroundColor && lbl.backgroundColor !== 'transparent') {
          ctx.fillStyle = lbl.backgroundColor;
          const textWidth = ctx.measureText(lbl.text).width;
          const padding = 6;
          ctx.fillRect(-textWidth/2 - padding, -rs/2 - padding, textWidth + padding*2, rs + padding*2);
        }
        
        ctx.fillStyle = lbl.color;
        ctx.font = `bold ${rs}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(lbl.text, 0, 0);
        ctx.restore();
        
        if (lbl.showPoint) {
          ctx.beginPath();
          ctx.fillStyle = lbl.color;
          ctx.arc(p.px, p.py, 5, 0, Math.PI * 2);
          ctx.fill();
        }
    });

    // Draw functions with improved algorithm
    compiledFunctions.forEach(f => {
      if (!f.visible || f.error || !f.node) return;
      
      const dMin = f.domainMin !== '' ? parseFloat(f.domainMin) : -Infinity;
      const dMax = f.domainMax !== '' ? parseFloat(f.domainMax) : Infinity;
      const rMin = f.rangeMin !== '' ? parseFloat(f.rangeMin) : -Infinity;
      const rMax = f.rangeMax !== '' ? parseFloat(f.rangeMax) : Infinity;
      
      if (f.operator === '>' || f.operator === '>=' || f.operator === '<' || f.operator === '<=') {
        // Draw inequality regions with gradient
        const res = 8;
        const rows = Math.ceil(height / res);
        const cols = Math.ceil(width / res);
        
        for (let j = 0; j < rows; j++) {
          for (let i = 0; i < cols; i++) {
            const m = toMath(i * res, j * res, width, height);
            if (m.x < dMin || m.x > dMax || m.y < rMin || m.y > rMax) continue;
            
            try {
              const val = f.compiled.evaluate({ x: m.x, y: m.y, ...f.context });
              let shouldFill = false;
              if (f.operator === '>') shouldFill = val > 0;
              else if (f.operator === '>=') shouldFill = val >= 0;
              else if (f.operator === '<') shouldFill = val < 0;
              else if (f.operator === '<=') shouldFill = val <= 0;
              
              if (shouldFill) {
                ctx.fillStyle = f.color + Math.round(f.fillOpacity * 255).toString(16).padStart(2, '0');
                ctx.fillRect(i * res, j * res, res, res);
              }
            } catch (e) {}
          }
        }
      }
      
      // Draw function curve
      const precision = Math.max(1, Math.min(5, Math.floor(zoom / 20)));
      const step = 1 / (zoom * precision);
      const startX = Math.floor(bounds.xMin / step) * step;
      const endX = Math.ceil(bounds.xMax / step) * step;
      
      ctx.beginPath();
      ctx.strokeStyle = f.color;
      ctx.lineWidth = f.thickness;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      
      let firstPoint = true;
      for (let x = startX; x <= endX; x += step) {
        if (x < dMin || x > dMax) continue;
        
        try {
          const val = f.compiled.evaluate({ x: x, y: 0, ...f.context });
          if (Math.abs(val) < 0.0001) {
            const y = 0; // Solve for y if possible
          }
          
          const y = val; // This needs actual solving
          if (y < rMin || y > rMax) continue;
          
          const p = toScreen(x, y, width, height);
          if (firstPoint) {
            ctx.moveTo(p.px, p.py);
            firstPoint = false;
          } else {
            ctx.lineTo(p.px, p.py);
          }
        } catch (e) {
          firstPoint = true;
        }
      }
      ctx.stroke();
    });

    // Draw graph title with enhanced styling
    if (graphTitle) {
      ctx.fillStyle = darkMode ? '#e2e8f0' : '#1e293b';
      ctx.font = 'bold 24px sans-serif';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0,0,0,0.1)';
      ctx.shadowBlur = 4;
      ctx.fillText(graphTitle, width / 2, 60);
      ctx.shadowBlur = 0;
    }

    // Draw cursor position if not dragging
    if (!isDragging && canvasRef.current) {
      canvasRef.current.onmousemove = (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const mathCoords = toMath(mx, my, width, height);
        
        ctx.fillStyle = darkMode ? '#cbd5e1' : '#475569';
        ctx.font = '12px monospace';
        ctx.textAlign = 'right';
        ctx.fillText(`x: ${mathCoords.x.toFixed(2)}, y: ${mathCoords.y.toFixed(2)}`, width - 10, 20);
      };
    }

  }, [
    compiledFunctions, showGrid, showAxes, showLabels, gridStepX, gridStepY,
    zoom, offset, graphTitle, labels, tables, images, sliders, currentContext,
    darkMode, isDragging
  ]);

  // Utility functions
  const toScreen = (x, y, width, height) => ({ 
    px: width / 2 + (x * zoom) + offset.x, 
    py: height / 2 - (y * zoom) + offset.y 
  });

  const toMath = (px, py, width, height) => ({ 
    x: (px - width / 2 - offset.x) / zoom, 
    y: (height / 2 - py + offset.y) / zoom 
  });

  const getBounds = () => {
    if (!canvasRef.current) return { xMin: -10, xMax: 10, yMin: -10, yMax: 10 };
    const width = canvasRef.current.width;
    const height = canvasRef.current.height;
    const tl = toMath(0, 0, width, height);
    const br = toMath(width, height, width, height);
    return { xMin: tl.x, xMax: br.x, yMin: br.y, yMax: tl.y };
  };

  const drawPoint = (ctx, px, py, shape, size, color) => {
    ctx.fillStyle = color;
    ctx.beginPath();
    switch (shape) {
      case 'square':
        ctx.rect(px - size, py - size, size * 2, size * 2);
        break;
      case 'triangle':
        ctx.moveTo(px, py - size);
        ctx.lineTo(px - size, py + size);
        ctx.lineTo(px + size, py + size);
        ctx.closePath();
        break;
      case 'diamond':
        ctx.moveTo(px, py - size);
        ctx.lineTo(px + size, py);
        ctx.lineTo(px, py + size);
        ctx.lineTo(px - size, py);
        ctx.closePath();
        break;
      case 'star':
        for (let i = 0; i < 5; i++) {
          const angle = i * (Math.PI * 2) / 5 - Math.PI/2;
          const x = px + Math.cos(angle) * size;
          const y = py + Math.sin(angle) * size;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        break;
      default: // circle
        ctx.arc(px, py, size, 0, Math.PI * 2);
    }
    ctx.fill();
  };

  const resolveVal = (val, context) => {
    if (typeof val === 'number') return val;
    if (val === '') return 0;
    try {
      return math.evaluate(String(val).toLowerCase(), context);
    } catch (e) {
      return parseFloat(val) || 0;
    }
  };

  // Auto-embed iframe with enhanced features
  const autoEmbedIframe = useMemo(() => {
    const baseUrl = window.location.origin + window.location.pathname;
    const dataToSave = {
        version: "2.0",
        f: functions,
        s: sliders,
        t: tables,
        l: labels,
        i: images.map(img => ({ 
          ...img, 
          src: img.element?.src || img.src,
          element: undefined 
        })),
        title: graphTitle,
        settings: { showGrid, showAxes, showLabels, darkMode }
    };
    
    try {
        const jsonString = JSON.stringify(dataToSave);
        const encodedData = btoa(encodeURIComponent(jsonString));
        
        return `<iframe 
  src="${baseUrl}?embed=true&data=${encodedData}" 
  width="800" 
  height="600" 
  style="border: 2px solid #6366f1; border-radius: 16px; box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.2);"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  loading="lazy"
></iframe>`;
    } catch (e) {
        return "Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„ØªØ¶Ù…ÙŠÙ†...";
    }
  }, [functions, sliders, tables, labels, images, graphTitle, showGrid, showAxes, showLabels, darkMode]);

  // Setup drawing loop
  useEffect(() => {
    draw();
    const handleResize = () => draw();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [draw]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Ctrl+Z for undo
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undo();
      }
      // Ctrl+Shift+Z or Ctrl+Y for redo
      if (((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') || ((e.ctrlKey || e.metaKey) && e.key === 'y')) {
        e.preventDefault();
        redo();
      }
      // Ctrl+S for save
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        handleSaveToFile();
      }
      // Space to toggle sidebar
      if (e.key === ' ' && !isEmbedMode) {
        e.preventDefault();
        setIsSidebarOpen(prev => !prev);
      }
      // Escape to cancel drag
      if (e.key === 'Escape') {
        setIsDragging(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, isEmbedMode]);

  return (
    <div className={`flex h-screen w-screen ${darkMode ? 'bg-gray-900 text-gray-100' : 'bg-white text-gray-900'} overflow-hidden font-sans text-right relative transition-colors duration-300`} dir="rtl">
      
      {/* Notification Toast */}
      {showNotification && (
        <div className={`fixed top-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-lg shadow-lg animate-slide-up ${
          showNotification.type === 'success' ? 'bg-gradient-to-r from-green-500 to-emerald-600' :
          showNotification.type === 'error' ? 'bg-gradient-to-r from-red-500 to-rose-600' :
          'bg-gradient-to-r from-blue-500 to-indigo-600'
        } text-white font-bold`}>
          {showNotification.message}
        </div>
      )}

      {/* Zoom Controls */}
      <div className={`zoom-controls ${isEmbedMode ? 'embed-hidden' : ''}`}>
          <button onClick={() => handleZoom(1)} className="zoom-btn tooltip" data-tooltip="ØªÙƒØ¨ÙŠØ± (Ctrl +)">+</button>
          <button onClick={() => setZoom(40)} className="zoom-btn tooltip" data-tooltip="Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªÙƒØ¨ÙŠØ±">âŒ</button>
          <button onClick={() => handleZoom(-1)} className="zoom-btn tooltip" data-tooltip="ØªØµØºÙŠØ± (Ctrl -)">âˆ’</button>
      </div>

      {/* Theme Toggle */}
      <button 
        onClick={() => setDarkMode(!darkMode)}
        className={`absolute top-4 left-4 z-50 p-3 rounded-full ${darkMode ? 'bg-yellow-100 text-yellow-600' : 'bg-gray-800 text-gray-100'} shadow-lg transition-all duration-300 ${isEmbedMode ? 'embed-hidden' : ''}`}
        data-tooltip={darkMode ? "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙØ§ØªØ­" : "Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø¯Ø§ÙƒÙ†"}
      >
        {darkMode ? 'â˜€ï¸' : 'ğŸŒ™'}
      </button>

      {/* Embed Controller */}
      {isEmbedMode && sliders.length > 0 && (
          <div className="embed-controller animate-slide-in">
              {sliders.map(s => (
                  <div key={s.id} className="flex items-center gap-4 p-2 bg-white/50 rounded-xl">
                      <button 
                        onClick={() => setSliders(prev => prev.map(item => item.id === s.id ? {...item, isAnimating: !item.isAnimating} : item))}
                        className={`w-10 h-10 rounded-full flex items-center justify-center text-white shadow-lg transition-all ${s.isAnimating ? 'gradient-warning animate-pulse' : 'gradient-primary'}`}
                      >
                        {s.isAnimating ? 'â¸ï¸' : 'â–¶ï¸'}
                      </button>
                      <div className="flex-1">
                          <div className="flex justify-between text-xs font-bold mb-1">
                              <span className="text-gray-700">{s.name}</span>
                              <span className="font-mono text-gray-900">{s.value.toFixed(2)}</span>
                          </div>
                          <input 
                            type="range" 
                            min={s.min} 
                            max={s.max} 
                            step={s.step} 
                            value={s.value} 
                            onChange={e => setSliders(prev => prev.map(item => item.id === s.id ? {...item, value: parseFloat(e.target.value)} : item))} 
                            className="w-full h-2 bg-gradient-to-r from-blue-200 to-indigo-200 rounded-lg appearance-none cursor-pointer [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:h-5 [&::-webkit-slider-thumb]:w-5 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:gradient-primary [&::-webkit-slider-thumb]:shadow-lg" 
                          />
                      </div>
                  </div>
              ))}
          </div>
      )}

      {/* Sidebar Toggle Button */}
      <button 
        onClick={() => setIsSidebarOpen(!isSidebarOpen)} 
        className={`absolute top-4 right-4 z-50 p-3 ${darkMode ? 'bg-gray-800 border-gray-700 text-gray-100' : 'bg-white border-gray-200 text-gray-600'} border shadow-lg rounded-full transition-all duration-300 hover:scale-105 ${isSidebarOpen ? 'mr-80' : 'mr-0'} ${isEmbedMode ? 'embed-hidden' : ''}`}
        data-tooltip={isSidebarOpen ? "Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©" : "ÙØªØ­ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©"}
      >
        <svg xmlns="http://www.w3.org/2000/svg" className={`h-6 w-6 transition-transform ${isSidebarOpen ? 'rotate-180' : ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
        </svg>
      </button>

      {/* Main Sidebar */}
      <div className={`fixed inset-y-0 right-0 w-80 ${darkMode ? 'bg-gray-800 border-gray-700' : 'bg-gradient-to-b from-slate-50 to-white border-gray-200'} border-l flex flex-col sidebar-scroll p-6 space-y-6 shadow-2xl z-40 transition-transform duration-300 ${isSidebarOpen ? 'translate-x-0' : 'translate-x-full'}`}>
        
        {/* Header */}
        <div className="flex items-center justify-between border-b pb-4">
          <h2 className="font-bold text-xl bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent">Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…</h2>
          <div className="flex gap-2">
            <button onClick={undo} disabled={historyIndex <= 0} className={`p-2 rounded-lg ${historyIndex <= 0 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-100'} transition-colors`} data-tooltip="ØªØ±Ø§Ø¬Ø¹ (Ctrl+Z)">â†¶</button>
            <button onClick={redo} disabled={historyIndex >= history.length - 1} className={`p-2 rounded-lg ${historyIndex >= history.length - 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-100'} transition-colors`} data-tooltip="Ø¥Ø¹Ø§Ø¯Ø© (Ctrl+Y)">â†·</button>
          </div>
        </div>

        {/* Quick Actions */}
        <div className="grid grid-cols-2 gap-3">
            <button onClick={() => {
                setFunctions([]);
                setSliders([]);
                setLabels([]);
                setTables([]);
                setImages([]);
                showToast('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø´Ø±ÙˆØ¹ Ø¬Ø¯ÙŠØ¯', 'success');
            }} className={`p-3 rounded-xl font-bold transition-all hover:scale-105 ${darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-white border hover:bg-gray-50'}`}>ğŸ“„ Ø¬Ø¯ÙŠØ¯</button>
            
            <label className={`p-3 rounded-xl font-bold text-center cursor-pointer transition-all hover:scale-105 ${darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-white border hover:bg-gray-50'}`}>
                ğŸ“‚ ÙØªØ­
                <input type="file" accept=".geolab,.json" className="hidden" onChange={(e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                // Validate and load data
                                if (data.version && data.version.startsWith('2')) {
                                    setFunctions(data.functions || []);
                                    setSliders(data.sliders || []);
                                    setLabels(data.labels || []);
                                    setTables(data.tables || []);
                                    setImages(data.images || []);
                                    setGraphTitle(data.graphTitle || '');
                                    setZoom(data.zoom || 40);
                                    setOffset(data.offset || { x: 0, y: 0 });
                                    if (data.settings) {
                                        setShowGrid(data.settings.showGrid ?? true);
                                        setShowAxes(data.settings.showAxes ?? true);
                                        setShowLabels(data.settings.showLabels ?? true);
                                        setGridStepX(data.settings.gridStepX || "auto");
                                        setGridStepY(data.settings.gridStepY || "auto");
                                        setDarkMode(data.settings.darkMode || false);
                                    }
                                    showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø¨Ù†Ø¬Ø§Ø­', 'success');
                                } else {
                                    showToast('Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…Ø©', 'error');
                                }
                            } catch (err) {
                                showToast('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù', 'error');
                            }
                        };
                        reader.readAsText(file);
                    }
                }} />
            </label>
        </div>

        {/* Save Options */}
        <div className="grid grid-cols-2 gap-3">
            <button onClick={handleSaveToFile} className="gradient-primary text-white p-3 rounded-xl font-bold transition-all hover:scale-105 shadow-lg">ğŸ’¾ Ø­ÙØ¸ Ù…Ø­Ù„ÙŠ</button>
            <button onClick={async () => {
                const token = prompt("Ø£Ø¯Ø®Ù„ Ø±Ù…Ø² GitHub Token Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ:");
                if(!token) return showToast('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­ÙØ¸', 'info');
                showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸ Ø¹Ø¨Ø± Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª...', 'info');
                // Implementation for GitHub Gist saving
            }} className="gradient-success text-white p-3 rounded-xl font-bold transition-all hover:scale-105 shadow-lg">â˜ï¸ Ø­ÙØ¸ Ø³Ø­Ø§Ø¨ÙŠ</button>
        </div>

        {/* Add Elements */}
        <div className="grid grid-cols-3 gap-2">
            <button onClick={() => setSliders([...sliders, { 
                id: 's'+Date.now(), 
                name: 'm', 
                value: 1, 
                min: -10, 
                max: 10, 
                step: 0.1, 
                isAnimating: false, 
                speed: 1, 
                mode: 'forward', 
                direction: 1,
                sinusoidalOffset: 0 
            }])} className="gradient-primary text-white p-2 rounded-lg text-xs font-bold transition-all hover:scale-105">+ Ù…Ù†Ø²Ù„Ù‚</button>
            
            <button onClick={() => setFunctions([...functions, { 
                id: 'f'+Date.now(), 
                expression: "y = sin(x)", 
                color: '#3b82f6', 
                visible: true, 
                thickness: 3, 
                domainMin: '', 
                domainMax: '', 
                rangeMin: '', 
                rangeMax: '',
                fillOpacity: 0.3
            }])} className="gradient-primary text-white p-2 rounded-lg text-xs font-bold transition-all hover:scale-105">+ Ø¯Ø§Ù„Ø©</button>
            
            <button onClick={() => setTables([...tables, { 
                id: 't'+Date.now(), 
                name: "Ø¬Ø¯ÙˆÙ„ Ø¬Ø¯ÙŠØ¯", 
                visible: true, 
                color: '#f59e0b', 
                pointShape: 'circle', 
                points: [{ x: "0", y: "0" }], 
                showLines: false,
                lineType: 'solid'
            }])} className="gradient-warning text-white p-2 rounded-lg text-xs font-bold transition-all hover:scale-105">+ Ø¬Ø¯ÙˆÙ„</button>
            
            <button onClick={() => setLabels([...labels, { 
                id: 'l'+Date.now(), 
                text: "Ù†Øµ Ø¬Ø¯ÙŠØ¯", 
                x: "2", 
                y: "2", 
                color: '#059669', 
                visible: true, 
                showPoint: true, 
                rotation: "0", 
                fontSize: "14",
                backgroundColor: 'transparent'
            }])} className="gradient-success text-white p-2 rounded-lg text-xs font-bold transition-all hover:scale-105">+ Ù†Øµ</button>
            
            <label className="gradient-danger text-white p-2 rounded-lg text-xs font-bold text-center cursor-pointer transition-all hover:scale-105">
                + ØµÙˆØ±Ø©
                <input type="file" accept="image/*" className="hidden" onChange={(e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const img = new Image();
                            img.src = event.target.result;
                            img.onload = () => {
                                setImages([...images, { 
                                    id: 'img' + Date.now(), 
                                    element: img, 
                                    x: "0", 
                                    y: "0", 
                                    width: "5", 
                                    rotation: "0", 
                                    opacity: "1", 
                                    visible: true 
                                }]);
                                showToast('ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØµÙˆØ±Ø©', 'success');
                            };
                        };
                        reader.readAsDataURL(file);
                    }
                }} />
            </label>
        </div>

        {/* Sliders Section */}
        {sliders.map(s => (
            <EnhancedSlider
                key={s.id}
                slider={s}
                onChange={(updated) => {
                    setSliders(prev => prev.map(item => item.id === s.id ? updated : item));
                    saveToHistory(`ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù…Ù†Ø²Ù„Ù‚ ${s.name}`);
                }}
                onDelete={() => {
                    setSliders(prev => prev.filter(item => item.id !== s.id));
                    saveToHistory(`Ø­Ø°Ù Ø§Ù„Ù…Ù†Ø²Ù„Ù‚ ${s.name}`);
                }}
            />
        ))}

        {/* Functions Section */}
        {functions.map(f => (
          <div key={f.id} className={`p-4 rounded-2xl shadow-medium space-y-3 ${darkMode ? 'bg-gray-700' : 'bg-gradient-to-br from-white to-blue-50'}`}>
            <div className="flex items-center gap-3">
                <input 
                    type="color" 
                    value={f.color} 
                    onChange={e => {
                        setFunctions(prev => prev.map(item => item.id === f.id ? {...item, color: e.target.value} : item));
                        saveToHistory(`ØªØ¹Ø¯ÙŠÙ„ Ù„ÙˆÙ† Ø§Ù„Ø¯Ø§Ù„Ø©`);
                    }}
                    className="w-8 h-8 border-none cursor-pointer rounded-lg"
                />
                <input 
                    type="text" 
                    className={`flex-1 p-2 rounded-lg font-mono text-sm ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
                    style={{ direction: 'ltr' }}
                    value={f.expression}
                    onChange={e => {
                        setFunctions(prev => prev.map(item => item.id === f.id ? {...item, expression: e.target.value} : item));
                        saveToHistory(`ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø§Ù„Ø©`);
                    }}
                    placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„ØªØ¹Ø¨ÙŠØ± Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠ..."
                />
                <button 
                    onClick={() => {
                        setFunctions(prev => prev.filter(item => item.id !== f.id));
                        saveToHistory(`Ø­Ø°Ù Ø§Ù„Ø¯Ø§Ù„Ø©`);
                    }}
                    className={`p-2 rounded-lg ${darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-100'}`}
                >
                    ğŸ—‘ï¸
                </button>
            </div>
            
            {f.error && (
                <div className="p-2 bg-red-100 text-red-700 rounded-lg text-xs">
                    âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ¹Ø¨ÙŠØ±: {f.errorMessage || 'ØªØ¹Ø¨ÙŠØ± ØºÙŠØ± ØµØ§Ù„Ø­'}
                </div>
            )}
            
            <div className="grid grid-cols-2 gap-2 text-xs">
                <div>
                    <label className="block text-xs font-bold mb-1">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ù…Ø¬Ø§Ù„</label>
                    <input 
                        type="text" 
                        className={`w-full p-1.5 rounded-lg ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                        value={f.domainMin}
                        onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, domainMin: e.target.value} : item))}
                        placeholder="auto"
                    />
                </div>
                <div>
                    <label className="block text-xs font-bold mb-1">Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ù…Ø¬Ø§Ù„</label>
                    <input 
                        type="text" 
                        className={`w-full p-1.5 rounded-lg ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                        value={f.domainMax}
                        onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, domainMax: e.target.value} : item))}
                        placeholder="auto"
                    />
                </div>
            </div>
            
            <div className="flex items-center justify-between text-xs">
                <div className="flex items-center gap-2">
                    <label>Ø³Ù…Ùƒ Ø§Ù„Ø®Ø·:</label>
                    <input 
                        type="range" 
                        min="1" 
                        max="10" 
                        value={f.thickness} 
                        onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, thickness: parseInt(e.target.value)} : item))}
                        className="w-20"
                    />
                    <span>{f.thickness}px</span>
                </div>
                <div className="flex items-center gap-2">
                    <label>Ø´ÙØ§ÙÙŠØ© Ø§Ù„ØªØ¹Ø¨Ø¦Ø©:</label>
                    <input 
                        type="range" 
                        min="0" 
                        max="100" 
                        value={f.fillOpacity * 100} 
                        onChange={e => setFunctions(prev => prev.map(item => item.id === f.id ? {...item, fillOpacity: parseInt(e.target.value) / 100} : item))}
                        className="w-20"
                    />
                    <span>{Math.round(f.fillOpacity * 100)}%</span>
                </div>
            </div>
          </div>
        ))}

        {/* Tables Section */}
        {tables.map(t => (
            <div key={t.id} className={`p-4 rounded-2xl shadow-medium space-y-3 ${darkMode ? 'bg-gray-700' : 'bg-gradient-to-br from-white to-amber-50'}`}>
                <div className="flex justify-between items-center border-b pb-2">
                    <div className="flex items-center gap-3">
                        <input 
                            type="color" 
                            value={t.color} 
                            onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, color: e.target.value} : item))}
                            className="w-6 h-6 border-none cursor-pointer rounded"
                        />
                        <input 
                            type="text" 
                            className={`text-sm font-bold bg-transparent ${darkMode ? 'text-gray-100' : 'text-gray-800'}`}
                            value={t.name}
                            onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, name: e.target.value} : item))}
                        />
                    </div>
                    <button 
                        onClick={() => {
                            setTables(prev => prev.filter(item => item.id !== t.id));
                            saveToHistory(`Ø­Ø°Ù Ø§Ù„Ø¬Ø¯ÙˆÙ„ ${t.name}`);
                        }}
                        className={`p-1.5 rounded-lg ${darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-100'}`}
                    >
                        ğŸ—‘ï¸
                    </button>
                </div>
                
                <div className="flex items-center justify-between text-xs mb-2">
                    <div className="flex items-center gap-3">
                        <div>
                            <label className="block text-xs font-bold mb-1">Ø´ÙƒÙ„ Ø§Ù„Ù†Ù‚Ø·Ø©</label>
                            <select 
                                value={t.pointShape} 
                                onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, pointShape: e.target.value} : item))}
                                className={`p-1.5 rounded-lg text-xs ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            >
                                <option value="circle">â— Ø¯Ø§Ø¦Ø±Ø©</option>
                                <option value="square">â–  Ù…Ø±Ø¨Ø¹</option>
                                <option value="triangle">â–² Ù…Ø«Ù„Ø«</option>
                                <option value="diamond">â—† Ù…Ø¹ÙŠÙ†</option>
                                <option value="star">â˜… Ù†Ø¬Ù…Ø©</option>
                            </select>
                        </div>
                        
                        <div>
                            <label className="block text-xs font-bold mb-1">Ù†ÙˆØ¹ Ø§Ù„Ø®Ø·</label>
                            <select 
                                value={t.lineType} 
                                onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, lineType: e.target.value} : item))}
                                className={`p-1.5 rounded-lg text-xs ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            >
                                <option value="solid">â”â”â” Ø®Ø· Ù…ØªØµÙ„</option>
                                <option value="dashed">â•â•â• Ø®Ø· Ù…ØªÙ‚Ø·Ø¹</option>
                            </select>
                        </div>
                    </div>
                    
                    <div className="flex items-center gap-2">
                        <label className="text-xs font-bold">Ø±Ø¨Ø· Ø§Ù„Ù†Ù‚Ø§Ø·:</label>
                        <input 
                            type="checkbox" 
                            checked={t.showLines}
                            onChange={e => setTables(prev => prev.map(item => item.id === t.id ? {...item, showLines: e.target.checked} : item))}
                            className="w-4 h-4"
                        />
                    </div>
                </div>
                
                <div className="overflow-x-auto">
                    <table className="w-full text-center text-xs">
                        <thead>
                            <tr className={`${darkMode ? 'bg-gray-600' : 'bg-gray-100'}`}>
                                <th className="p-2 rounded-r-lg">X</th>
                                <th className="p-2">Y</th>
                                <th className="p-2 rounded-l-lg"></th>
                            </tr>
                        </thead>
                        <tbody>
                            {t.points.map((p, idx) => (
                                <tr key={idx} className={`${darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-50'}`}>
                                    <td className="p-1.5">
                                        <input 
                                            type="text" 
                                            className={`w-full p-1.5 rounded text-center ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-gray-100'}`}
                                            value={p.x}
                                            onChange={e => setTables(prev => prev.map(tab => tab.id === t.id ? {
                                                ...tab, 
                                                points: tab.points.map((pt, i) => i === idx ? {...pt, x: e.target.value} : pt)
                                            } : tab))}
                                        />
                                    </td>
                                    <td className="p-1.5">
                                        <input 
                                            type="text" 
                                            className={`w-full p-1.5 rounded text-center ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-gray-100'}`}
                                            value={p.y}
                                            onChange={e => setTables(prev => prev.map(tab => tab.id === t.id ? {
                                                ...tab, 
                                                points: tab.points.map((pt, i) => i === idx ? {...pt, y: e.target.value} : pt)
                                            } : tab))}
                                        />
                                    </td>
                                    <td className="p-1.5">
                                        <button 
                                            onClick={() => setTables(prev => prev.map(tab => tab.id === t.id ? {
                                                ...tab, 
                                                points: tab.points.filter((_, i) => i !== idx)
                                            } : tab))}
                                            className="p-1.5 text-red-500 hover:bg-red-50 rounded-lg transition-colors"
                                        >
                                            âœ•
                                        </button>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
                
                <button 
                    onClick={() => setTables(prev => prev.map(tab => tab.id === t.id ? {
                        ...tab, 
                        points: [...tab.points, {x: "0", y: "0"}]
                    } : tab))}
                    className={`w-full py-2 text-xs font-bold rounded-lg transition-all hover:scale-105 ${darkMode ? 'bg-gray-600 hover:bg-gray-500' : 'bg-gray-100 hover:bg-gray-200'}`}
                >
                    + Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© Ø¬Ø¯ÙŠØ¯Ø©
                </button>
            </div>
        ))}

        {/* Labels Section */}
        {labels.map(lbl => (
            <div key={lbl.id} className={`p-4 rounded-2xl shadow-medium space-y-3 ${darkMode ? 'bg-gray-700' : 'bg-gradient-to-br from-white to-emerald-50'}`}>
                <div className="flex justify-between items-center border-b pb-2">
                    <div className="flex items-center gap-3">
                        <input 
                            type="color" 
                            value={lbl.color} 
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, color: e.target.value} : item))}
                            className="w-6 h-6 border-none cursor-pointer rounded"
                        />
                        <span className="text-sm font-bold">ğŸ“ ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù†Øµ</span>
                    </div>
                    <button 
                        onClick={() => {
                            setLabels(prev => prev.filter(item => item.id !== lbl.id));
                            saveToHistory(`Ø­Ø°Ù Ø§Ù„Ù†Øµ`);
                        }}
                        className={`p-1.5 rounded-lg ${darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-100'}`}
                    >
                        ğŸ—‘ï¸
                    </button>
                </div>
                
                <input 
                    type="text" 
                    className={`w-full p-3 rounded-lg text-sm ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100 text-gray-800'}`}
                    value={lbl.text}
                    onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, text: e.target.value} : item))}
                    placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§..."
                />
                
                <div className="grid grid-cols-2 gap-3">
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠ X</label>
                        <input 
                            type="text" 
                            className={`w-full p-2 rounded-lg text-center ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            value={lbl.x}
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, x: e.target.value} : item))}
                        />
                    </div>
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠ Y</label>
                        <input 
                            type="text" 
                            className={`w-full p-2 rounded-lg text-center ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            value={lbl.y}
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, y: e.target.value} : item))}
                        />
                    </div>
                </div>
                
                <div className="grid grid-cols-2 gap-3">
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø­Ø¬Ù… Ø§Ù„Ø®Ø·</label>
                        <input 
                            type="range" 
                            min="8" 
                            max="72" 
                            value={lbl.fontSize} 
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, fontSize: e.target.value} : item))}
                            className="w-full"
                        />
                        <div className="text-center text-xs mt-1">{lbl.fontSize}px</div>
                    </div>
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¯ÙˆØ±Ø§Ù†</label>
                        <input 
                            type="range" 
                            min="0" 
                            max="360" 
                            value={lbl.rotation} 
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, rotation: e.target.value} : item))}
                            className="w-full"
                        />
                        <div className="text-center text-xs mt-1">{lbl.rotation}Â°</div>
                    </div>
                </div>
                
                <div className="flex items-center justify-between text-xs">
                    <div className="flex items-center gap-2">
                        <label>Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©:</label>
                        <input 
                            type="color" 
                            value={lbl.backgroundColor} 
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, backgroundColor: e.target.value} : item))}
                            className="w-6 h-6 border-none cursor-pointer rounded"
                        />
                    </div>
                    <div className="flex items-center gap-2">
                        <label>Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†Ù‚Ø·Ø©:</label>
                        <input 
                            type="checkbox" 
                            checked={lbl.showPoint}
                            onChange={e => setLabels(prev => prev.map(item => item.id === lbl.id ? {...item, showPoint: e.target.checked} : item))}
                            className="w-4 h-4"
                        />
                    </div>
                </div>
            </div>
        ))}

        {/* Images Section */}
        {images.map(img => (
            <div key={img.id} className={`p-4 rounded-2xl shadow-medium space-y-3 ${darkMode ? 'bg-gray-700' : 'bg-gradient-to-br from-white to-rose-50'}`}>
                <div className="flex justify-between items-center border-b pb-2">
                    <span className="text-sm font-bold flex items-center gap-2">
                        ğŸ–¼ï¸ ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØµÙˆØ±Ø©
                    </span>
                    <button 
                        onClick={() => {
                            setImages(prev => prev.filter(item => item.id !== img.id));
                            saveToHistory(`Ø­Ø°Ù Ø§Ù„ØµÙˆØ±Ø©`);
                        }}
                        className={`p-1.5 rounded-lg ${darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-100'}`}
                    >
                        ğŸ—‘ï¸
                    </button>
                </div>
                
                <div className="grid grid-cols-2 gap-3">
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠ X</label>
                        <input 
                            type="text" 
                            className={`w-full p-2 rounded-lg text-center ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            value={img.x}
                            onChange={e => setImages(prev => prev.map(item => item.id === img.id ? {...item, x: e.target.value} : item))}
                        />
                    </div>
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠ Y</label>
                        <input 
                            type="text" 
                            className={`w-full p-2 rounded-lg text-center ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            value={img.y}
                            onChange={e => setImages(prev => prev.map(item => item.id === img.id ? {...item, y: e.target.value} : item))}
                        />
                    </div>
                </div>
                
                <div className="grid grid-cols-2 gap-3">
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¹Ø±Ø¶</label>
                        <input 
                            type="text" 
                            className={`w-full p-2 rounded-lg text-center ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                            value={img.width}
                            onChange={e => setImages(prev => prev.map(item => item.id === img.id ? {...item, width: e.target.value} : item))}
                        />
                    </div>
                    <div>
                        <label className="block text-xs font-bold mb-1">Ø§Ù„Ø´ÙØ§ÙÙŠØ©</label>
                        <input 
                            type="range" 
                            min="0" 
                            max="100" 
                            value={parseFloat(img.opacity) * 100} 
                            onChange={e => setImages(prev => prev.map(item => item.id === img.id ? {...item, opacity: (parseFloat(e.target.value) / 100).toString()} : item))}
                            className="w-full"
                        />
                        <div className="text-center text-xs mt-1">{Math.round(parseFloat(img.opacity) * 100)}%</div>
                    </div>
                </div>
                
                <div>
                    <label className="block text-xs font-bold mb-1">Ø§Ù„Ø¯ÙˆØ±Ø§Ù†</label>
                    <input 
                        type="range" 
                        min="0" 
                        max="360" 
                        value={img.rotation} 
                        onChange={e => setImages(prev => prev.map(item => item.id === img.id ? {...item, rotation: e.target.value} : item))}
                        className="w-full"
                    />
                    <div className="text-center text-xs mt-1">{img.rotation}Â°</div>
                </div>
            </div>
        ))}

        {/* Footer Section */}
        <div className="mt-auto pt-4 border-t border-slate-200 space-y-4">
            {/* Embed Code */}
            <div className={`p-4 rounded-2xl shadow-medium space-y-3 ${darkMode ? 'bg-gray-700' : 'bg-gradient-to-br from-indigo-50 to-purple-50'}`}>
                <label className="text-sm font-bold text-indigo-700 flex items-center gap-2">
                    <span>ğŸ“‹ ÙƒÙˆØ¯ Ø§Ù„ØªØ¶Ù…ÙŠÙ† Ø§Ù„Ø°ÙƒÙŠ</span>
                    <button 
                        onClick={() => {
                            navigator.clipboard.writeText(autoEmbedIframe);
                            showToast('ØªÙ… Ù†Ø³Ø® ÙƒÙˆØ¯ Ø§Ù„ØªØ¶Ù…ÙŠÙ†', 'success');
                        }}
                        className="text-xs px-2 py-1 bg-indigo-100 text-indigo-700 rounded-lg hover:bg-indigo-200"
                    >
                        Ù†Ø³Ø®
                    </button>
                </label>
                <textarea 
                    readOnly 
                    className={`w-full p-3 text-xs font-mono rounded-lg resize-none ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-800'}`}
                    rows="4" 
                    value={autoEmbedIframe} 
                    onClick={(e) => e.target.select()}
                />
                <p className="text-xs text-slate-500">* ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙˆØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ø£ÙŠ ØªØºÙŠÙŠØ± ÙÙŠ Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ.</p>
            </div>

            {/* Export Image */}
            <button 
                onClick={() => {
                    const canvas = canvasRef.current;
                    if (canvas) {
                        const link = document.createElement('a');
                        link.download = `${graphTitle.replace(/\s+/g, '_')}_${Date.now()}.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                        showToast('ØªÙ… ØªØµØ¯ÙŠØ± Ø§Ù„ØµÙˆØ±Ø©', 'success');
                    }
                }}
                className="w-full py-3 gradient-success text-white rounded-xl font-bold transition-all hover:scale-105 shadow-lg flex items-center justify-center gap-2"
            >
                ğŸ“· ØªØµØ¯ÙŠØ± ÙƒØµÙˆØ±Ø© PNG
            </button>

            {/* Grid Controls */}
            <div className={`grid grid-cols-2 gap-3 p-4 rounded-2xl shadow-medium ${darkMode ? 'bg-gray-700' : 'bg-white'}`}>
                <div>
                    <label className="block text-xs font-bold mb-2">ØªØ¨Ø§Ø¹Ø¯ Ø§Ù„Ø´Ø¨ÙƒØ© - X</label>
                    <select 
                        value={gridStepX} 
                        onChange={e => setGridStepX(e.target.value)}
                        className={`w-full p-2 rounded-lg text-sm ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                    >
                        {gridOptions.map(opt => (
                            <option key={opt} value={opt}>{opt === 'pi' ? 'Ï€' : opt === 'Ï€/2' ? 'Ï€/2' : opt === 'Ï€/4' ? 'Ï€/4' : opt}</option>
                        ))}
                    </select>
                </div>
                <div>
                    <label className="block text-xs font-bold mb-2">ØªØ¨Ø§Ø¹Ø¯ Ø§Ù„Ø´Ø¨ÙƒØ© - Y</label>
                    <select 
                        value={gridStepY} 
                        onChange={e => setGridStepY(e.target.value)}
                        className={`w-full p-2 rounded-lg text-sm ${darkMode ? 'bg-gray-600 text-gray-100' : 'bg-gray-100'}`}
                    >
                        {gridOptions.map(opt => (
                            <option key={opt} value={opt}>{opt === 'pi' ? 'Ï€' : opt === 'Ï€/2' ? 'Ï€/2' : opt === 'Ï€/4' ? 'Ï€/4' : opt}</option>
                        ))}
                    </select>
                </div>
            </div>

            {/* Display Settings */}
            <div className={`space-y-3 p-4 rounded-2xl shadow-medium ${darkMode ? 'bg-gray-700' : 'bg-white'}`}>
                <div className="text-xs font-bold text-slate-600 mb-2">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶</div>
                <div className="space-y-2">
                    <div className="flex justify-between items-center">
                        <span className="text-sm">Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù…Ø­Ø§ÙˆØ±</span>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input 
                                type="checkbox" 
                                checked={showAxes} 
                                onChange={e => setShowAxes(e.target.checked)}
                                className="sr-only peer"
                            />
                            <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>
                    <div className="flex justify-between items-center">
                        <span className="text-sm">Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø´Ø¨ÙƒØ©</span>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input 
                                type="checkbox" 
                                checked={showGrid} 
                                onChange={e => setShowGrid(e.target.checked)}
                                className="sr-only peer"
                            />
                            <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>
                    <div className="flex justify-between items-center">
                        <span className="text-sm">Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø£Ø±Ù‚Ø§Ù…</span>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input 
                                type="checkbox" 
                                checked={showLabels} 
                                onChange={e => setShowLabels(e.target.checked)}
                                className="sr-only peer"
                            />
                            <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>
                </div>
            </div>

            {/* Clear Data */}
            <button 
                onClick={() => {
                    if (window.confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©ØŸ')) {
                        localStorage.clear();
                        window.location.reload();
                        showToast('ØªÙ… Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
                    }
                }}
                className="w-full py-3 gradient-danger text-white rounded-xl font-bold transition-all hover:scale-105 shadow-lg"
            >
                ğŸ—‘ï¸ Ù…Ø³Ø­ ÙƒØ§ÙØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
            </button>

            {/* Version Info */}
            <div className="text-center text-xs text-slate-500 pt-2">
                Ù…ÙˆÙ‚Ø¹ Ø§Ù„ØªÙƒØ§Ù…Ù„ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… v2.0 â€¢ ØªÙ… Ø§Ù„ØªØ·ÙˆÙŠØ± Ø¨ÙˆØ§Ø³Ø·Ø© ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„ÙˆÙŠØ¨ Ø§Ù„Ø­Ø¯ÙŠØ«Ø©
            </div>
        </div>
      </div>

      {/* Main Canvas */}
      <div className="flex-1 relative">
        <canvas 
            ref={canvasRef} 
            onPointerDown={(e) => {
                setIsDragging(true);
                dragStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
                e.currentTarget.setPointerCapture(e.pointerId);
            }}
            onPointerMove={(e) => {
                if (isDragging) {
                    setOffset({ 
                        x: e.clientX - dragStart.current.x, 
                        y: e.clientY - dragStart.current.y 
                    });
                }
            }}
            onPointerUp={(e) => {
                setIsDragging(false);
                e.currentTarget.releasePointerCapture(e.pointerId);
            }}
            onWheel={(e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                setZoom(z => Math.min(config.maxZoom, Math.max(config.minZoom, z * zoomFactor)));
            }}
            className={`w-full h-full ${isDragging ? 'cursor-grabbing' : 'cursor-grab'}`}
        />
        
        {/* Graph Title Editor */}
        {!isEmbedMode && (
            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-30">
                <input 
                    type="text" 
                    className={`text-center p-3 rounded-xl font-bold text-lg shadow-lg ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-800'}`}
                    value={graphTitle}
                    onChange={e => setGraphTitle(e.target.value)}
                    style={{ width: '400px' }}
                    placeholder="Ø£Ø¯Ø®Ù„ Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ..."
                />
            </div>
        )}

        {/* Current Coordinates Display */}
        {!isEmbedMode && (
            <div className={`absolute bottom-4 right-4 px-4 py-2 rounded-lg shadow-lg ${darkMode ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-800'}`}>
                <div className="text-xs font-mono">
                    Ø§Ù„ØªÙƒØ¨ÙŠØ±: {zoom.toFixed(1)}x â€¢ Ø§Ù„Ø¥Ø²Ø§Ø­Ø©: ({offset.x.toFixed(0)}, {offset.y.toFixed(0)})
                </div>
            </div>
        )}
      </div>
    </div>
  );
};

const root = ReactDOM.createRoot(document.getElementById('geometry-engine-root'));
root.render(<App />);
</script>
</body>
</html>
